<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>唐伯虎点蜡烛</title>
  <subtitle>YOU&#39;VE MADE A &lt;span&gt;BRAVE&lt;/span&gt; DECISION, WELCOME.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haymaicc.github.io/"/>
  <updated>2017-05-17T05:13:11.000Z</updated>
  <id>http://haymaicc.github.io/</id>
  
  <author>
    <name>杨励志</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>zookeeper 学习</title>
    <link href="http://haymaicc.github.io/2017/05/17/zk/"/>
    <id>http://haymaicc.github.io/2017/05/17/zk/</id>
    <published>2017-05-17T04:37:07.000Z</published>
    <updated>2017-05-17T05:13:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://haymaicc.github.io/res/zk.png" alt=""></p>
<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ol>
<li>分布式通知，协调</li>
<li>集群管理</li>
<li>Master 选举</li>
<li>分布式锁 分布式队列</li>
</ol>
<a id="more"></a>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><blockquote>
<p>类似于文件系统结构，每一个节点称为ZNode   可以存放数据</p>
</blockquote>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ol>
<li>2n+1 个server   当n+1个节点可用时，系统可用</li>
<li>server 角色类型 存放数据  ( leader： 不接受客户端请求负责投票和决议，最终更新状态     </li>
<li>follwer：接受客户端请求并返回，参与leader 发起的投票</li>
</ol>
<h2 id="leader-选举"><a href="#leader-选举" class="headerlink" title="leader 选举"></a>leader 选举</h2><blockquote>
<p>leader 失去Leader 地位时使用paxos 算法选举</p>
</blockquote>
<ol>
<li>每一个server向所有server 请求成为leader</li>
<li>投票超过一半的成为leader ,否则重新执行第一步</li>
</ol>
<h2 id="数据交互"><a href="#数据交互" class="headerlink" title="数据交互"></a>数据交互</h2><ul>
<li>读：直接 读取client连接的server 的数据</li>
<li>更新  1、 client向server发送请求 2、server向leader发送请求 3、leader发起proposol过程 4、follower反馈结果 5、leader接收响应，如果超过⼀半认为成功，则认为 成功，否则认为失败。并将结果反馈给server 6、server将结果反馈给client</li>
</ul>
<h2 id="ObServer节点"><a href="#ObServer节点" class="headerlink" title="ObServer节点"></a>ObServer节点</h2><p>ObServer节点：和client交互，存有数据的副本，不参与投票</p>
<h2 id="client架构"><a href="#client架构" class="headerlink" title="client架构"></a>client架构</h2><ol>
<li>ClientCnxn：管理  client和ZooKeeper间  的网络连接</li>
<li>WatcherManager：管 理Watcher，如：负 责对ZNode的监控</li>
<li>Zookeeper：Client交 互的主要接⼝，如创 建Znode、更新ZNode</li>
</ol>
<h2 id="ZooKeeper承诺"><a href="#ZooKeeper承诺" class="headerlink" title="ZooKeeper承诺"></a>ZooKeeper承诺</h2><p>顺序性  原⼦性 强⼀致性 可靠性 实时性</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://haymaicc.github.io/res/zk.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;应用场景：&quot;&gt;&lt;a href=&quot;#应用场景：&quot; class=&quot;headerlink&quot; title=&quot;应用场景：&quot;&gt;&lt;/a&gt;应用场景：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;分布式通知，协调&lt;/li&gt;
&lt;li&gt;集群管理&lt;/li&gt;
&lt;li&gt;Master 选举&lt;/li&gt;
&lt;li&gt;分布式锁 分布式队列&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="分布式" scheme="http://haymaicc.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://haymaicc.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构学习笔记（三）</title>
    <link href="http://haymaicc.github.io/2017/05/16/data-structure3/"/>
    <id>http://haymaicc.github.io/2017/05/16/data-structure3/</id>
    <published>2017-05-16T04:47:05.000Z</published>
    <updated>2017-05-30T04:16:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://haymaicc.github.io/2017/05/06/data_structure1/">笔记（一）的传送门</a><br><a href="https://haymaicc.github.io/2017/05/07/data-structure2/">笔记（二）的传送门</a></p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><blockquote>
<p>查找就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素</p>
</blockquote>
<h2 id="顺序查找-O-n"><a href="#顺序查找-O-n" class="headerlink" title="顺序查找 O(n)"></a>顺序查找 O(n)</h2><blockquote>
<p>从表中第一个记录开始，逐个与给定值进行比较，若某个记录的关键字和给定值相等，则查找成功；反之，若直到最后一个记录，其关键字和给定值都不相等，则表明表中没有所查记录，查找失败。</p>
</blockquote>
<a id="more"></a>
<h3 id="二分-折半查找（有序表）-O-logn"><a href="#二分-折半查找（有序表）-O-logn" class="headerlink" title="二分/折半查找（有序表） O(logn)"></a>二分/折半查找（有序表） O(logn)</h3><blockquote>
<p>先确定待查记录所在的范围，然后逐步缩小范围，直到找到或者找不到记录为止。</p>
</blockquote>
<h3 id="插值查找-O-logn"><a href="#插值查找-O-logn" class="headerlink" title="插值查找  O(logn)"></a>插值查找  O(logn)</h3><blockquote>
<p>插值查找和折半查找类似，可以通过比较表中的某项记录，确定查找记录的范围。唯一不同的是，对每次查找的中间点进行了变换，使之更加接近待查找的记录，减少了查找的次数。折半查找的中间点mid = low + (high – low) / 2，插值查找对1/2进行了修正，mid = low + (key – a[low])/(a[high] – a[low]) * (high – low)</p>
</blockquote>
<h3 id="斐波那契查找-O-logn"><a href="#斐波那契查找-O-logn" class="headerlink" title="斐波那契查找 O(logn)"></a>斐波那契查找 O(logn)</h3><blockquote>
<p>依然是对查找点的优化，采用Fibonacci数组，找到对于当前长度的有序表的黄金分割点，作为每次的中间值。</p>
</blockquote>
<p>对于平均性能，斐波那契查找要优于折半查找，但如果是最坏情况，查找效率低于折半查找。有序表查找是一种针对查找优化的表结构，查找的时间复杂度是O(logn)。但有序表的插入和删除性能是比较差的，插入和删除不能破坏有序表的特性。</p>
<h2 id="线形索引查找"><a href="#线形索引查找" class="headerlink" title="线形索引查找"></a>线形索引查找</h2><blockquote>
<p>索引是关键词和记录关联的过程，按照结构可以分为线形索引，树形索引和多级索引。线形索引就是将索引项集合组织为线形结构，也称索引表。</p>
</blockquote>
<h3 id="稠密索引-O-logn"><a href="#稠密索引-O-logn" class="headerlink" title="稠密索引 O(logn)"></a>稠密索引 O(logn)</h3><blockquote>
<p>稠密索引是关键码有序的，因此可以对索引使用折半、插值、斐波那契等有序表查找算法，大大提高了效率。</p>
</blockquote>
<p>优缺点：和有序表类似的是，稠密索引必须要维护索引的有序性。另外如果数据量很大，也要同时维护一个同样规模的索引，可能就需要反复访问磁盘，降低了查找性能。</p>
<h3 id="分块索引-介于O-n-和O-logn-之间"><a href="#分块索引-介于O-n-和O-logn-之间" class="headerlink" title="分块索引  介于O(n)和O(logn)之间"></a>分块索引  介于O(n)和O(logn)之间</h3><blockquote>
<p>如果对索引进行一次分级呢？对于一级索引下，可能会有多个记录，称之为一个块，块内的记录再获得一个二级的索引。这些块有一个条件，就是块内无序，块间有序。块内无序就是在一级索引内部的记录可以是无序的，只要落在索引的范围内就可以；块间有序就是下一个块所有的关键字都要大于上一个块的最大关键字。因此对于一个块结构来讲，它具有最大关键码，块中的记录个数和指向块首数据的指针</p>
</blockquote>
<p>分块索引兼顾了有序和无序的需求，平衡了插入，删除和查找的性能，普遍用于数据库查找技术等</p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><blockquote>
<p>倒排索引主要应用于搜索引擎。基本思想就是将得到的key-value关系进行一个反映射，得到某个value有多少个key指向它。比如查找某个单词出现在哪些文章中，可以先访问文章中的所有单词，建立一个单词的索引，将出现该单词的文章记录到索引中。这样在搜索时直接输入单词，就能得到文章列表。</p>
</blockquote>
<p>优缺点：倒排索引的优点是速度快，缺点就是记录不等长，维护比较困难，插入和删除都要做相应的处理。比如删除某个文章，就可能要对所有的单词都进行考察。</p>
<h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><blockquote>
<p>有序表的问题就是如果插入一个较小的记录，就要把比它大的记录依次移动，腾出插入的位置。如果用二叉树来实现呢，只需要让这个较小的记录成为某个结点的左孩子就可以了。为什么是左孩子呢，和二叉排序数的定义有关，简单来说，二叉排序树的中序遍历就是一个有序表。这样插入任何一个记录都不需要改变已经建好的树</p>
</blockquote>
<h3 id="查找："><a href="#查找：" class="headerlink" title="查找："></a>查找：</h3><blockquote>
<p>查找某个记录时，从根结点开始，如果查找记录大于该结点的值，就走右子树；如果小于该结点的值，就走左子树。不断向下查找，直到找到该记录，或者到叶子结点的值和查找记录不同，未找到该记录。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入和查找类似，向下找到最接近它的结点，然后把该记录作为它的左孩子或者右孩子。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除相对查找和插入来讲复杂一点，主要复杂在如果处理它的子树。删除分为几种情况，如果删除结点是叶子结点，直接把它和二叉排序树断开即可，不影响树上的其他结点。如果删除结点带左子树或者右子树（不同时），那就将它左子树或者右子树的根结点代替它，连接到树上。如果删除结点同时带有左子树和右子树呢？想要对原排序树的破坏最小，最好的办法是找到该结点的前驱或者后继结点，这可以很容易的找到。假设我们这里使用删除结点的前驱结点，要先将前驱结点的值赋给删除结点，如果前驱结点就是删除结点的左孩子（删除结点及其子孙只有左孩子，斜树），就将前驱结点的左子树接到删除结点的左子树上；如果前驱结点是某个结点的右孩子（删除结点及其子孙不只有左孩子），还要将它的左子树接到它父母的右子树上。</p>
<p>###时间复杂度<br>如果二叉排序树是平衡的，那么查找的时间复杂度是O(logn)；如果是不平衡，比如最极端的斜树，那么时间复杂度是O(n)。</p>
<p>###优缺点<br>二叉排序树保留了有序表查找高效的特点，最理想的情况能达到O(logn)的时间复杂度，并且解决了插入和删除记录的问题，能够保证树的整体结构不受影响。缺点就是可能在插入的过程中，二叉排序树不能保持平衡，出现了某一边的树远远大于另一边，降低了查找的效率。后面提到的平衡二叉树解决了这个问题。</p>
</blockquote>
<h2 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h2><blockquote>
<p>平衡二叉树的出现是为了解决二叉排序树可能出现的不平衡问题。平衡二叉树的概念是树中任何结点的平衡因子只能是-1,0,1，也就左子树和右子树的深度相差最多是1。为了实现这个目的，每次插入记录后，都会检查二叉树是否处在平衡状态，如果不是的话，会进行相应的旋转操作使之平衡。平衡的过程就是从新插入的结点向上查找，如果某个结点的BF=2，就顺时针旋转。最简单的旋转就是对于斜树，直接将BF=2结点的孩子作为新的子树根结点，将BF=2连接到它的右孩子。稍复杂的旋转就是BF=2和它的左孩子有相同的旋转方向，这样将它的左孩子作为新的子数根结点，BF=2连接在新根结点的右子树上，再将新的根结点原来的右孩子连接到BF=2的左子树上。最复杂的旋转就是BF=2和它的左孩子是相反的旋转方向，就要将它的左孩子先进行一次右旋转，再对BF=2作左旋转。同样，如果找到某个结点的BF=-2，做逆时针旋转，旋转的方法和顺时针旋转类似。</p>
</blockquote>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><blockquote>
<p>由于平衡二叉树的特性，它的时间复杂度一直是O(logn)。</p>
</blockquote>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><blockquote>
<p>平衡二叉树的优点就在于将不平衡消灭在最初的阶段，保持了很好的查找特性。缺点？比较复杂？</p>
</blockquote>
<h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><blockquote>
<p>其中的每一个节点都具有两个孩子（称为2节点）或者三个孩子（称为3节点）。并且2-3树中所有的叶子都在同一层上。<br> 一个2节点包含一个元素和两个孩子（或者没有孩子）。<br> 一个3节点包含一小一大两个元素和三个孩子（或者没有孩子）<br><img src="https://haymaicc.github.io/res/structure_1.jpg" alt=""></p>
</blockquote>
<h3 id="2-3树的插入实现"><a href="#2-3树的插入实现" class="headerlink" title="2-3树的插入实现"></a>2-3树的插入实现</h3><p>(1)对于空树，插入一个2节点即可；<br>(2)插入节点到一个2节点的叶子上。由于本身就只有一个元素，所以只需要将其升级为3节点即可。<br><img src="https://haymaicc.github.io/res/structure_2.jpg" alt=""><br>(3)插入节点到一个3节点的叶子上。因为3节点本身最大容量，因此需要拆分，且将树中两元素或者插入元素的三者中选择其一向上移动一层。<br><img src="https://haymaicc.github.io/res/structure_3.jpg" alt=""></p>
<h3 id="2-3树的删除实现"><a href="#2-3树的删除实现" class="headerlink" title="2-3树的删除实现"></a>2-3树的删除实现</h3><p>(1)所删元素位于一个3节点的叶子节点上，直接删除，不会影响树结构。<br>(2)所删元素位于一个2节点上，直接删除，破坏树结构<br>分为四种情况<br><img src="https://haymaicc.github.io/res/structure_4.jpg" alt=""><br>3）所删元素位于非叶子的分支节点。此时按树中序遍历得到此元素的前驱或后续元素，补位。<br><img src="https://haymaicc.github.io/res/structure_5.jpg" alt=""></p>
<h2 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h2><blockquote>
<p>2-3-4树是2-3树的扩展，包括了4节点的使用，一个4节点包含小中大三个元素和四个孩子（或没有孩子）。</p>
</blockquote>
<h3 id="2-3-4树插入实现"><a href="#2-3-4树插入实现" class="headerlink" title="2-3-4树插入实现"></a>2-3-4树插入实现</h3><p>构建一个数组为{7,1,2,5,6,9,8,4,3}的2-3-4树的过程<br><img src="https://haymaicc.github.io/res/structure_6.jpg" alt=""></p>
<h3 id="2-3-4树删除实现"><a href="#2-3-4树删除实现" class="headerlink" title="2-3-4树删除实现"></a>2-3-4树删除实现</h3><p>删除顺序使1,6,3,4,5,2,9<br><img src="https://haymaicc.github.io/res/structure_7.jpg" alt=""></p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://haymaicc.github.io/2017/05/06/data_structure1/&quot;&gt;笔记（一）的传送门&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://haymaicc.github.io/2017/05/07/data-structure2/&quot;&gt;笔记（二）的传送门&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;查找&quot;&gt;&lt;a href=&quot;#查找&quot; class=&quot;headerlink&quot; title=&quot;查找&quot;&gt;&lt;/a&gt;查找&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;查找就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;顺序查找-O-n&quot;&gt;&lt;a href=&quot;#顺序查找-O-n&quot; class=&quot;headerlink&quot; title=&quot;顺序查找 O(n)&quot;&gt;&lt;/a&gt;顺序查找 O(n)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;从表中第一个记录开始，逐个与给定值进行比较，若某个记录的关键字和给定值相等，则查找成功；反之，若直到最后一个记录，其关键字和给定值都不相等，则表明表中没有所查记录，查找失败。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://haymaicc.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://haymaicc.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>各种IO的区别</title>
    <link href="http://haymaicc.github.io/2017/05/07/IO/"/>
    <id>http://haymaicc.github.io/2017/05/07/IO/</id>
    <published>2017-05-07T15:07:20.000Z</published>
    <updated>2017-05-07T15:11:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BIO（同步阻塞IO）"><a href="#BIO（同步阻塞IO）" class="headerlink" title="BIO（同步阻塞IO）"></a>BIO（同步阻塞IO）</h2><p>使用ServerSocket绑定IP地址和监听端口，客户端发起连接，通过三次握手建立连接，用socket来进行通信，通过输入输出流的方式来进行同步阻塞的通信<br>每次客户端发起连接请求，都会启动一个线程<br>线程数量：客户端并发访问数为1：1，由于线程是JAVA虚拟机中非常宝贵的资源，一旦线程数急剧增加，系统性能会急剧下降，导致线程栈溢出，创建新的线程失败，并最终导致宕机<br>所以在JDK1.4之前，人们想到了一种方法，即PIO方式</p>
<a id="more"></a>
<h2 id="PIO（伪异步阻塞IO）"><a href="#PIO（伪异步阻塞IO）" class="headerlink" title="PIO（伪异步阻塞IO）"></a>PIO（伪异步阻塞IO）</h2><p>使用线程池来处理客户端的请求<br>客户端个数：线程池最大线程数=M：N，其中M远大于N<br>在read和write的时候，还是IO阻塞的，只是把每个线程交由线程池来控制管理</p>
<h2 id="NIO（异步阻塞IO）"><a href="#NIO（异步阻塞IO）" class="headerlink" title="NIO（异步阻塞IO）"></a>NIO（异步阻塞IO）</h2><p>用NIO方式处理IO<br>使用多路复用器Selector来轮询每个通道Channel，当通道中有事件时就通知处理，不会阻塞<br>使用相当复杂</p>
<h2 id="AIO（真正的异步非阻塞IO）"><a href="#AIO（真正的异步非阻塞IO）" class="headerlink" title="AIO（真正的异步非阻塞IO）"></a>AIO（真正的异步非阻塞IO）</h2><p>NIO2.0引入了新的异步通道的概念，不需要使用多路复用器（Selector）对注册通道进行轮询即可实现异步读写，从而简化了NIO编程模型</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;BIO（同步阻塞IO）&quot;&gt;&lt;a href=&quot;#BIO（同步阻塞IO）&quot; class=&quot;headerlink&quot; title=&quot;BIO（同步阻塞IO）&quot;&gt;&lt;/a&gt;BIO（同步阻塞IO）&lt;/h2&gt;&lt;p&gt;使用ServerSocket绑定IP地址和监听端口，客户端发起连接，通过三次握手建立连接，用socket来进行通信，通过输入输出流的方式来进行同步阻塞的通信&lt;br&gt;每次客户端发起连接请求，都会启动一个线程&lt;br&gt;线程数量：客户端并发访问数为1：1，由于线程是JAVA虚拟机中非常宝贵的资源，一旦线程数急剧增加，系统性能会急剧下降，导致线程栈溢出，创建新的线程失败，并最终导致宕机&lt;br&gt;所以在JDK1.4之前，人们想到了一种方法，即PIO方式&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大话数据结构学习笔记（二）</title>
    <link href="http://haymaicc.github.io/2017/05/07/data-structure2/"/>
    <id>http://haymaicc.github.io/2017/05/07/data-structure2/</id>
    <published>2017-05-07T12:01:05.000Z</published>
    <updated>2017-05-16T05:33:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://haymaicc.github.io/2017/05/06/data_structure1/">笔记（一）的传送门</a></p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><blockquote>
<p>是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为G(V,E)，其中G表示一个图，V是图G中的顶点，E是图G中边的集合</p>
</blockquote>
<a id="more"></a>
<h3 id="关于图的一些术语解释"><a href="#关于图的一些术语解释" class="headerlink" title="关于图的一些术语解释"></a>关于图的一些术语解释</h3><p><code>顶点（Vertex）</code>：<br>图中的结点又称为顶点。 </p>
<p><code>无边图</code>：<br>若顶点Vi到Vj之间的边没有方向，则称这条边为无项边（Edge），用序偶对(Vi,Vj)标示。<br>对于下图无向图G1来说，G1=(V1, {E1})，其中顶点集合V1={A,B,C,D}；边集合E1={(A,B),(B,C),(C,D),(D,A),(A,C)}:<br><img src="http://images.cnitblog.com/blog/380281/201307/13102520-912a10a40eb347b1a550f60a4feaae02.png" alt=""></p>
<p><code>有向图</code>：<br>若从顶点Vi到Vj的边是有方向的，则成这条边为有向边，也称为弧（Arc）。用有序对（Vi，Vj）标示，Vi称为弧尾，Vj称为弧头。如果任意两条边之间都是有向的，则称该图为有向图。<br>有向图G2中，G2=（V2,{E2}），顶点集合（A,B,C,D）,弧集合E2={<a,d>,{B,A},<c,a>,<b,c>}.</b,c></c,a></a,d></p>
<p><code>有向和无向完全图</code><br><img src="http://img.blog.csdn.net/20131113203819437" alt=""></p>
<p><code>权（Weight）</code>：<br>有些图的边和弧有相关的数，这个数叫做权（Weight）。这些带权的图通常称为网（Network）</p>
<p><code>度（Degree）</code>：<br>无向图中顶点v的度是关联于该顶点的边的数目，记为TD(v)。<br>入度（Indegree）：若G为有向图，则把以顶点v为终点的边的数目，称为v的入度，记为ID(v)。<br>出度（Outdegree）：若G为有向图，则把以顶点v为始点的边的数目，称为v的出度，记为OD(v)。<br>如图①：A的度为3。<br>如图②：A的入度为2，出度为1，所以A的度为3。<br><img src="http://img.blog.csdn.net/20131113205232156" alt=""></p>
<p><code>子图（Subgraph</code>：<br>设G=(V,E)是一个图，若E’是E的子集，V’是V的子集，使得E’中的边仅与V’中顶点相关联，则图G’=(V’,E’)称为图G的子图。<br>如图：②为①的4个子图<br><img src="http://img.blog.csdn.net/20131112231539062" alt=""></p>
<p><code>路径（Path</code><br>无向图G=(V,E)中从顶点v到顶点v’的路径是一个顶点序列(v=vi0,vi1,…,vin=v’)，其中(vij-1,vij)∈E，1≤j≤n。有向图G=(V,E)中从顶点v到顶点v’的路径是一个顶点序列(v=vi0,vi1,…,vin=v’)，其中〈vij-1,vij〉∈E，1≤j≤n。<br>　简单路径：序列中顶点不重复出现的路径。<br>　环（Cycle）：又称回路，第一个顶点和最后一个顶点相同的路径。<br>　简单回路：又称简单环，除了第一个顶点和最后一个顶点外，其余顶点不重复的回路。</p>
<p><code>连通</code>：<br>在无向图G中，如果从顶点v到顶点v’有路径，则称v和v’是连通的。<br>    连通图（Connected Graph）：如果对于图中的任意两个顶点vi、vj∈V，vi和vj都是连通的，则称该图为连通图。<br>    连通分量（Connected Component）：无向图中的极大连通子图。<br>    强连通图：在有向图G中，如果对于每一对vi，vj∈V，vi≠vj，从vi到vj和从vj到vi都存在路径，则称G是强连通图。<br>    强连通分量：有向图中的极大连通子图<br><img src="http://img.blog.csdn.net/20131113205509265" alt=""></p>
<p><code>生成树（Spanning Tree）</code>：<br>含有连通图的全部顶点的一个极小连通子图。</p>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><p><code>邻接矩阵</code>：<br>图的邻接矩阵存储方式是用两个数组来标示图。一个一位数组存储图顶点的信息，一个二维数组（称为邻接矩阵）存储图中边或者弧的信息。</p>
<p>设图G有n个顶点，则邻接矩阵是一个n*n的方阵，定义为：<br><img src="http://images.cnitblog.com/blog/380281/201307/13102724-c49b3c87958e493696d55d3306597b5c.png" alt=""></p>
<p>实例如下，左图是一个无向图。右图是邻接矩阵表示：<br><img src="http://images.cnitblog.com/blog/380281/201307/13102739-ae381b43e0124cc7908c055f350dc03a.png" alt=""></p>
<p>无向网图的创建代码，时间复杂度为O{n + n2 + e}。</p>
<p><code>邻接表</code><br>用数组和链表结合的存储方式来标示图的方法称为邻接表。</p>
<blockquote>
<p>原理：（类似于树的孩子表示法的第三种存储方式）<br>图中顶点用一个一维数组存储，当然也可以用单链表存储。<br>图中每个顶点 Vi 的所有邻接点构成一个线性表，由于邻接点的个数不确定，所以我们选择用单链表来存储。无向图成为顶点vi的边表，有向图则称为顶点vi作为弧尾的出边表。</p>
</blockquote>
<p><img src="http://images.cnitblog.com/blog/380281/201307/13103212-bec29eec5fda4044a93ee18ee4c10607.png" alt=""></p>
<p><code>十字链表（OrthogonalList）</code><br>十字链表把邻接表与逆邻接表结合起来，解决了出度和入度的问题。</p>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><blockquote>
<p>从图中某个顶点出发访遍图中其余顶点，且使每个顶点仅被访问依次，这一过程叫做图的遍历.</p>
</blockquote>
<p>遍历方法： 深度优先遍历和广度优先遍历</p>
<p><code>深度优先遍历 O(n^2)</code>：从图中某个顶点出发v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先便利图，直到图中所有和v有相同路径的顶点都被访问。</p>
<p><code>广度优先遍历（Breadth_First_Search）O(n^2)</code> 又称为广度优先搜索，简称BFS</p>
<p>深度优先更适合目标比较明确，以找到目标为主要目的的情况。<br>广度优先更适合在不断扩大遍历范围时找到相对最优解的情况。</p>
<h3 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h3><p><code>最小生成树（普里姆算法 O(n^2)）</code></p>
<blockquote>
<p>我们把构造连通图的最小代价生成树称为最小生成树</p>
</blockquote>
<p>最小生成树实现算法：普利姆算法和克鲁斯卡尔算法</p>
<p><code>普利姆算法</code></p>
<blockquote>
<p>假设 N=(P, {E})是连通网， TE是N上最小生成树中边的集合。算法从 U={u0}（u0∈V），TE={}开始。重复执行下述操作：在所有 u∈U,v∈V-U的边（u,v）∈E中找一条代价最小的边（u0,v0）并入集合TE，同时v0并入U，直至U=V为止。此时TE中必有 n-1条边。则T=（V,{TE}）为最小生成树。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prim</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;Vertex&gt; vertexList = <span class="keyword">new</span> ArrayList&lt;Vertex&gt;();<span class="comment">//结点集</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;Edge&gt; EdgeQueue = <span class="keyword">new</span> ArrayList&lt;Edge&gt;();<span class="comment">//边集</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;Vertex&gt; newVertex = <span class="keyword">new</span> ArrayList&lt;Vertex&gt;();<span class="comment">//已经 访问过的结点</span></div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		primTree();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">()</span> </span>&#123;</div><div class="line">		Vertex v1 = <span class="keyword">new</span> Vertex(<span class="string">"a"</span>);</div><div class="line">		Prim.vertexList.add(v1);</div><div class="line">		Vertex v2 = <span class="keyword">new</span> Vertex(<span class="string">"b"</span>);</div><div class="line">		Prim.vertexList.add(v2);</div><div class="line">		Vertex v3 = <span class="keyword">new</span> Vertex(<span class="string">"c"</span>);</div><div class="line">		Prim.vertexList.add(v3);</div><div class="line">		Vertex v4 = <span class="keyword">new</span> Vertex(<span class="string">"d"</span>);</div><div class="line">		Prim.vertexList.add(v4);</div><div class="line">		Vertex v5 = <span class="keyword">new</span> Vertex(<span class="string">"e"</span>);</div><div class="line">		Prim.vertexList.add(v5);</div><div class="line">		addEdge(v1, v2, <span class="number">6</span>);</div><div class="line">		addEdge(v1, v3, <span class="number">7</span>);</div><div class="line">		addEdge(v2, v3, <span class="number">8</span>);</div><div class="line">		addEdge(v2, v5, <span class="number">4</span>);</div><div class="line">		addEdge(v2, v4, <span class="number">5</span>);</div><div class="line">		addEdge(v3, v4, <span class="number">3</span>);</div><div class="line">		addEdge(v3, v5, <span class="number">9</span>);</div><div class="line">		addEdge(v5, v4, <span class="number">7</span>);</div><div class="line">		addEdge(v5, v1, <span class="number">2</span>);</div><div class="line">		addEdge(v4, v2, <span class="number">2</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Vertex a, Vertex b, <span class="keyword">int</span> w)</span> </span>&#123;</div><div class="line">		Edge e = <span class="keyword">new</span> Edge(a, b, w);</div><div class="line">		Prim.EdgeQueue.add(e);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">primTree</span><span class="params">()</span></span>&#123;</div><div class="line">		buildGraph();</div><div class="line">		Vertex start = vertexList.get(<span class="number">0</span>);</div><div class="line">		newVertex.add(start);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;vertexList.size()-<span class="number">1</span>;n++)&#123;</div><div class="line">			Vertex temp = <span class="keyword">new</span> Vertex(start.key);</div><div class="line">			Edge tempedge = <span class="keyword">new</span> Edge(start,start,<span class="number">1000</span>);</div><div class="line">			<span class="keyword">for</span>(Vertex v : newVertex)&#123;</div><div class="line">				<span class="keyword">for</span>(Edge e : EdgeQueue)&#123;</div><div class="line">					<span class="keyword">if</span>(e.start==v &amp;&amp; !containVertex(e.end))&#123;</div><div class="line">						<span class="keyword">if</span>(e.key&lt;tempedge.key)&#123;</div><div class="line">							temp = e.end;</div><div class="line">							tempedge = e;</div><div class="line">						&#125;	</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			newVertex.add(temp);</div><div class="line">		&#125;</div><div class="line">		Iterator it = newVertex.iterator();</div><div class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">			Vertex v =(Vertex) it.next();</div><div class="line">			System.out.println(v.key);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containVertex</span><span class="params">(Vertex vte)</span></span>&#123;</div><div class="line">		<span class="keyword">for</span>(Vertex v : newVertex)&#123;</div><div class="line">			<span class="keyword">if</span>(v.key.equals(vte.key))</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> </span>&#123;</div><div class="line">	String key;</div><div class="line">	Vertex(String key)&#123;</div><div class="line">		<span class="keyword">this</span>.key = key;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span>&#123;</div><div class="line">	Vertex start;</div><div class="line">	Vertex end;</div><div class="line">	<span class="keyword">int</span> key;</div><div class="line">	Edge(Vertex start,Vertex end,<span class="keyword">int</span> key)&#123;</div><div class="line">		<span class="keyword">this</span>.start = start;</div><div class="line">		<span class="keyword">this</span>.end  = end;</div><div class="line">		<span class="keyword">this</span>.key = key;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>克鲁斯卡尔算法</code></p>
<blockquote>
<p>假设 N=（V, {E}）是连通网，则令最小生成树的初始状态为只有n个顶点而无边的非连通图 T={V,{}}，图中每个顶点自成一格连通分量。在 E 中选择代价最小的边，若该边依附的顶点落在 T 中不同的连通分量上，则将此边加入到T中，否则舍去此边而选择下一条代价最小的边。以此类推，直至T中所有顶点都在同一连通分量上为止。</p>
</blockquote>
<p>1、新建图G，G中拥有原图中相同的节点，但没有边<br>2、将原图中所有的边按权值从小到大排序<br>3、从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边到图G中<br>4、重复3，直至图G中所有的节点都在同一个连通分量中</p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><blockquote>
<p>对于网图来说，最短路径是指两个顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点式源点，最后一个顶点是终点。</p>
</blockquote>
<p>两种计算最短路径算法：迪杰斯特拉(Djikstra)算法和佛洛伊德算法</p>
<p><code>迪杰斯特拉(Djikstra)算法 O(n^2)</code><br>迪杰斯特拉算法并不是一下子求出开始节点到尾节点的最短路径，而是一步步求出它们之间顶点的最短路径，过程中都是基于已经求出的最短路径的基础上，求得更远顶点的最短路径，最终得到你要的结果。运用的是贪心算法，如果v1-&gt;..-&gt;vi-&gt;…-&gt;vn 是最短路径，那v1-&gt;vi,vi-&gt;vn也是最短路径。</p>
<p><code>佛洛依德算法 O(n^3)</code></p>
<blockquote>
<p>通过Floyd计算图G=(V,E)中各个顶点的最短路径时，需要引入一个矩阵S，矩阵S中的元素a[i][j]表示顶点i(第i个顶点)到顶点j(第j个顶点)的距离。<br>假设图G中顶点个数为N，则需要对矩阵S进行N次更新。初始时，矩阵S中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞。 接下来开始，对矩阵S进行N次更新。第1次更新时，如果”a[i][j]的距离” &gt; “a[i][0]+a[0][j]”(a[i][0]+a[0][j]表示”i与j之间经过第1个顶点的距离”)，则更新a[i][j]为”a[i][0]+a[0][j]”。 同理，第k次更新时，如果”a[i][j]的距离” &gt; “a[i][k]+a[k][j]”，则更新a[i][j]为”a[i][k]+a[k][j]”。更新N次之后，操作完成！<br>详见<a href="http://www.cnblogs.com/skywang12345/p/3711532.html" target="_blank" rel="external">佛洛依德算法</a>，算法推导过程就是构建矩阵的过程。</p>
</blockquote>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><blockquote>
<p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为AOV网(Activity On Vertex)。<br>设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列V1,V2…..,Vn满足若从顶点Vi到顶点Vj有一条路径，则在顶点序列中Vi必在Vj顶点之前。则我们称这样的顶点序列为拓扑序列。<br>所谓拓扑序列，其实就是对一个有向图构造拓扑序列的过程。</p>
</blockquote>
<p>拓扑排序：是将一个AOV网的各个顶点按一定顺序排列，要求满足若存在<vi，vj>，则排序中的顶点Vi必在顶点Vj之前。对于同一幅图，拓扑排序可有多个拓扑排序。</vi，vj></p>
<p>算法：<br>（1）从有向图中选择一个无前驱（入度为0）的顶点输出。<br>（2）删除此顶点，并删除已此顶点为为尾的弧。<br>（3）重复（1），（2）步骤，知道输出全部顶点或者AOV网中不存在入度为0的顶点。</p>
<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><blockquote>
<p>在一个表示工程的带权有向图中，用顶点表示事件，用有向图表示活动，用边上的权值表示活动的持续事件，这种这种有向图的边表示活动图，我们称之为AOE网(Activity On Edge Network)。<br>我们把路径上各个活动所持续的时间之和称为路径的长度，从原点到汇点具有最大长度的路径叫做关键路径，在关键路径上的活动叫关键活动。</p>
</blockquote>
<p>算法:<br>(1) 从开始顶点V0出发，假设ve(0)=0，然后按照拓扑有序求出其他各顶点i的最早开始时间ve(i)，如果得到拓扑序列中顶点数目小于图中的顶点数，则表示图中存在回路，算法结束，否则继续执行。<br>(2) 从结束顶点Vn出发，假设vl(n-1) = ve(n-1);然后求出各顶点i的最晚发生时间。<br>(3) 根据顶点的最早发生时间，和最晚发生时间，依次求出出每条弧的最早开始时间和最晚开始时间，如果两只相等，则为关键活动。关键活动组成的路径则为关键路径。</p>
<p>拓扑排序和关键路径 使用邻接表存储数据，最小生成树和最短路径用 邻接矩阵 存储数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://haymaicc.github.io/2017/05/06/data_structure1/&quot;&gt;笔记（一）的传送门&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;图&quot;&gt;&lt;a href=&quot;#图&quot; class=&quot;headerlink&quot; title=&quot;图&quot;&gt;&lt;/a&gt;图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为G(V,E)，其中G表示一个图，V是图G中的顶点，E是图G中边的集合&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://haymaicc.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://haymaicc.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构学习笔记（一）</title>
    <link href="http://haymaicc.github.io/2017/05/06/data_structure1/"/>
    <id>http://haymaicc.github.io/2017/05/06/data_structure1/</id>
    <published>2017-05-06T10:32:35.000Z</published>
    <updated>2017-05-07T11:59:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据结构</strong>在面试中经常遇到，以前没有系统的梳理过，最近在看《大话数据结构》，所以想整理一些笔记，供日后参考。</p>
<p><img src="http://g-ec4.images-amazon.com/images/G/28/book/jiangwei201110/dahuashujuejiegou_778-300._V165998284_.jpg" alt=""></p>
<a id="more"></a>
<hr>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p> 是相互之间存在一种或多种特定关系的数据元素的集合，按照视点的不同，可分为:</p>
<blockquote>
<p><strong>逻辑结构</strong>：集合结构，线形结构，树形结构，图形结构<br><strong>物理结构</strong>：顺序存储结构，链式存储结构</p>
</blockquote>
<hr>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote>
<p>算法是解决问题的方法。</p>
</blockquote>
<p>五个特性：输入，输出，有穷性，确定性和可行性。<br>算法设计的要求：正确性，可读性，健壮性，时间效率高和存储量低<br>算法效率的度量方法：事后统计，事前分析<br>算法时间复杂度：一般采用大O记法，O(1)叫常数阶，O(n)线形阶，O（n^2）平方阶…</p>
<h3 id="推导大O的方法"><a href="#推导大O的方法" class="headerlink" title="推导大O的方法"></a><code>推导大O的方法</code></h3><p>1、用常数1取代运行时间中的所有加法常数<br>2、在修改后的运行次数函数中，只保留最高阶项<br>3、如果最高阶项存在且不是1，则去除与这个项相乘的常数</p>
<h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><table>
<thead>
<tr>
<th style="text-align:center">执行次数</th>
<th style="text-align:center">函数阶</th>
<th style="text-align:center">非正式术语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">常数阶</td>
</tr>
<tr>
<td style="text-align:center">2n+3</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">线形阶</td>
</tr>
<tr>
<td style="text-align:center">3n^2+2n+1</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">平方阶</td>
</tr>
<tr>
<td style="text-align:center">5logn+20</td>
<td style="text-align:center">O(logn)</td>
<td style="text-align:center">对数阶</td>
</tr>
<tr>
<td style="text-align:center">2n+3nlogn+19</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">nlogn阶</td>
</tr>
<tr>
<td style="text-align:center">6n^3+2n^2+3n+4</td>
<td style="text-align:center">O(n^3)</td>
<td style="text-align:center">立方阶</td>
</tr>
<tr>
<td style="text-align:center">2^n</td>
<td style="text-align:center">O(2^n)</td>
<td style="text-align:center">指数阶</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="线形表"><a href="#线形表" class="headerlink" title="线形表"></a>线形表</h2><blockquote>
<p>零个或多个数据元素的有限序列</p>
</blockquote>
<h3 id="线形表的顺序存储结构"><a href="#线形表的顺序存储结构" class="headerlink" title="线形表的顺序存储结构"></a>线形表的顺序存储结构</h3><blockquote>
<p>用一段地址连续的存储单元依次存储线形表的数据元素<br>    |a1|a2|……|a(i-1)|ai|……|an|</p>
</blockquote>
<p><code>顺序存储结构需要三个属性</code><br><strong>存储空间的起始位置</strong>：数组data，他的存储位置就是存储空间的存储位置。<br><strong>线形表的最大存储容量</strong>：数组长度MaxSize<br><strong>线形表的当前长度</strong>：length</p>
<p>第i个数据元素ai的存储位置可以由a1推算得出 LOC(ai) = LOC(a1)+(i-1)*c </p>
<p>因此存取的时间复杂度是O(1)，由于插入删除需要移动后面节点的位置，所以插入删除的时间复杂度是O(n)</p>
<h3 id="线形表的链式存储结构"><a href="#线形表的链式存储结构" class="headerlink" title="线形表的链式存储结构"></a>线形表的链式存储结构</h3><blockquote>
<p>用一组任意的存储单元存储线形表的数据元素，这组存储单元可以是连续的，也可以是不连续的<br>    |……|0900(头指针)|……|a1(地址0900)|0700|……|an|null|……|</p>
</blockquote>
<p>单链表插入与删除的时间复杂度是O(1)，存取的时间复杂度是O(n)</p>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><blockquote>
<p>一些早期的编程高级语言，如Basic，Fortran等，由于没有指针，无法实现链表结构，于是想出用数组来代替指针，这种链表叫静态链表，也叫游标实现法</p>
</blockquote>
<p>让数组的元素由两个数据域组成，data和cur，cur相当于单链表中的next指针，存放该元素的后继在数组中的位置。</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><blockquote>
<p>将单链表的终端节点由空指针改成指向头节点，使单链表形成一个环，这种头尾相连的单链表称为单循环链表，简称单链表</p>
</blockquote>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><blockquote>
<p>为了解决单向链表不能找前继节点的缺点而设计，在单链表的基础上再加一个指针，指向前继节点</p>
</blockquote>
<hr>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><blockquote>
<p>限定在表尾进行插入和删除操作的线形表。允许插入和删除的一段叫栈顶，另一端叫栈尾。 是后进先出（Last In First Out）的线形表，简称LIFO结构。</p>
</blockquote>
<h4 id="栈的顺序存储结构及实现"><a href="#栈的顺序存储结构及实现" class="headerlink" title="栈的顺序存储结构及实现"></a>栈的顺序存储结构及实现</h4><p>让数组下标为0的一端作为栈底，入栈和出栈的时间复杂度都是O(1)<br>对于两个相同类型的栈可以设置两栈共享空间，最大限度利用事先开辟的空间来操作：将两个栈的栈底分别设置为一个数组的两端，然后向中间靠拢。</p>
<h4 id="栈的链式存储结构及实现"><a href="#栈的链式存储结构及实现" class="headerlink" title="栈的链式存储结构及实现"></a>栈的链式存储结构及实现</h4><p>把栈顶设置在链表的头部，而且在这种结构中，头节点失去了意义，不需要头节点</p>
<hr>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><blockquote>
<p>只允许在一端进行插入操作，而在另一端进行删除操作的线形表，是一种先进先出（First In First Out）的线形表，简称FIFO结构</p>
</blockquote>
<p>队列的顺序存储结构的入队操作时间复杂度是O(1)，出队操作是O(n)<br>队列的链式存储结构其实就是单链表，只不过它只能尾进头出</p>
<hr>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><blockquote>
<p>由零个或多个字符组成的有限序列，又名字符串</p>
</blockquote>
<p>这里不做赘述，可以了解下这里的两个算法，<a href="http://www.csdn.net/allenalex/article/details/11721097" target="_blank" rel="external">朴素的模式匹配算法</a>和<a href="http://blog.csdn.net/allenalex/article/details/11726107" target="_blank" rel="external">KMP模式匹配算法</a></p>
<hr>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><blockquote>
<p>n(n&gt;=0) 个结点的有限集。 n=0时称为空树。在任意一个非空树中：<br>1、有且只有一个特定的称为根（Root）的结点；<br>2、当n&gt;1时其余结点可分为m（m&gt;0）个互不相交的有限集T1，T2…Tm，其中每个集合本身又是一个树，并且称为根的子树（SubTree）</p>
</blockquote>
<p>结点的最大层次称为树的高度或深度，子树的个数称为树的度</p>
<h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><p>1、双亲表示法 （data，parent）<br>2、孩子表示法 （data，child1，child2，child3…）<br>3、孩子兄弟表示法 （data，firstchild，rightsib）</p>
<h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><blockquote>
<p>二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）</p>
</blockquote>
<p><code>二叉树的性质</code><br>1、在二叉树的第i层至多由2^(i-1)个结点<br>2、在深度为k的二叉树至多由2^k-1个结点（k&gt;=1）<br>3、在任何一个二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1<br>4、具有n个结点的完全二叉树的深度为|logn+1|（|n|表示不大于n的最大整数）</p>
<p><code>二叉树的存储结构</code><br>1、二叉树的顺序存储结构：在一棵n个结点的完全二叉树中，从树根起，自上层到下层，每层从左至右，给所有结点编号，能得到一个反映整个二叉树结构的线性序列，如果不是完全二叉树<br>会造成空间上的浪费，所以一般只用于完全二叉树<br>2、二叉树的链式存储结构：二叉链表（lchild，data，rchild）</p>
<p><code>遍历二叉树</code>：前序遍历，中序遍历，后序遍历，层序遍历</p>
<p><code>线索二叉树</code>：二叉树添加了直接指向节点的前驱和后继的指针的二叉树称为线索二叉树</p>
<p><code>哈夫曼树</code>：哈夫曼树是一种带权路径长度最短的二叉树，也称为最优二叉树。下面用一幅图来说明。<br><img src="http://images.cnitblog.com/blog/311549/201309/19165401-f8340a5a1ee64e48aff958ce3d7f37b4.jpg" alt=""></p>
<blockquote>
<p>它们的带权路径长度分别为：<br>图a： WPL=5<em>2+7</em>2+2<em>2+13</em>2=54<br>图b： WPL=5<em>3+2</em>3+7<em>2+13</em>1=48<br>可见，图b的带权路径长度较小，我们可以证明图b就是哈夫曼树(也称为最优二叉树)</p>
</blockquote>
<p><code>哈夫曼树的构造(哈夫曼算法)</code><br>1.根据给定的n个权值{w1,w2,…,wn}构成二叉树集合F={T1,T2,…,Tn},其中每棵二叉树Ti中只有一个带权为wi的根结点,其左右子树为空.<br>2.在F中选取两棵根结点权值最小的树作为左右子树构造一棵新的二叉树,且置新的二叉树的根结点的权值为左右子树根结点的权值之和.<br>3.在F中删除这两棵树,同时将新的二叉树加入F中.<br>4.重复2、3,直到F只含有一棵树为止.(得到哈夫曼树)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;数据结构&lt;/strong&gt;在面试中经常遇到，以前没有系统的梳理过，最近在看《大话数据结构》，所以想整理一些笔记，供日后参考。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://g-ec4.images-amazon.com/images/G/28/book/jiangwei201110/dahuashujuejiegou_778-300._V165998284_.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://haymaicc.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://haymaicc.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java 代码执行linux命令</title>
    <link href="http://haymaicc.github.io/2017/03/10/java_execute_shell/"/>
    <id>http://haymaicc.github.io/2017/03/10/java_execute_shell/</id>
    <published>2017-03-10T10:32:35.000Z</published>
    <updated>2017-05-07T10:12:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>在做一个java执行pyhton脚本命令时在网上找了许多方案都不行，最后在stackoverflow上<br>找到，执行脚本的时候需要带上shell的版本，类似于bash，zsh。看了下服务器上的是zsh，<br><a id="more"></a><br>于是优化代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.xiamu.utils;</div><div class="line"><span class="keyword">import</span> org.slf4j.Logger;</div><div class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Description: 调用脚本帮助类</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> haoyuan.yang</div><div class="line"> * <span class="doctag">@version</span> 1.0</div><div class="line"> * <span class="doctag">@date</span>: 2017/3/10</div><div class="line"> * <span class="doctag">@since</span> JDK 1.8</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PythonUtil</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(PythonUtil.class);</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Description:调用系统命令</div><div class="line">	 *</div><div class="line">	 * <span class="doctag">@author</span> haoyuan.yang</div><div class="line">	 * <span class="doctag">@version</span> 1.0</div><div class="line">	 * <span class="doctag">@date</span>: 2017/3/10 17:55</div><div class="line">	 * <span class="doctag">@since</span> JDK 1.8</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeCommand</span><span class="params">(String command)</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Process proc = Runtime.getRuntime()</div><div class="line">					.exec(<span class="keyword">new</span> String[] &#123; <span class="string">"zsh"</span>, <span class="string">"-c"</span>, command &#125;);</div><div class="line">			proc.waitFor();</div><div class="line">			BufferedReader reader = <span class="keyword">new</span> BufferedReader(</div><div class="line">					<span class="keyword">new</span> InputStreamReader(proc.getInputStream()));</div><div class="line">			StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">			String line;</div><div class="line">			<span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">				sb.append(line).append(<span class="string">"\n"</span>);</div><div class="line">			&#125;</div><div class="line">			logger.info(<span class="string">"execute command &#123;&#125; , result is &#123;&#125;"</span>, command, sb.toString());</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			logger.info(<span class="string">"execute command &#123;&#125; fault, e=&#123;&#125;"</span>, command, e.getMessage());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做一个java执行pyhton脚本命令时在网上找了许多方案都不行，最后在stackoverflow上&lt;br&gt;找到，执行脚本的时候需要带上shell的版本，类似于bash，zsh。看了下服务器上的是zsh，&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://haymaicc.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://haymaicc.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>排序算法Java实现</title>
    <link href="http://haymaicc.github.io/2016/12/05/sort/"/>
    <id>http://haymaicc.github.io/2016/12/05/sort/</id>
    <published>2016-12-05T10:20:12.000Z</published>
    <updated>2017-05-07T08:27:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序-0-N-2"><a href="#冒泡排序-0-N-2" class="headerlink" title="冒泡排序 0(N^2)"></a>冒泡排序 0(N^2)</h3><p>执行非常慢，概念上最简单。最大的会一直被交换，冒泡上来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span>[] arrays = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span> &#125;;</div><div class="line"><span class="keyword">int</span> out, in;</div><div class="line"><span class="keyword">for</span> (out = arrays.length - <span class="number">1</span>; out &gt; <span class="number">1</span>; out--) &#123; <span class="comment">// outer loop(backward)</span></div><div class="line">    <span class="keyword">for</span> (in = <span class="number">0</span>; in &lt; out; in++) &#123; <span class="comment">// inter loop(forward)</span></div><div class="line">        <span class="keyword">if</span> (arrays[in] &gt; arrays[in + <span class="number">1</span>]) &#123; <span class="comment">// out of order</span></div><div class="line">            <span class="keyword">int</span> temp = arrays[in]; <span class="comment">// swap them</span></div><div class="line">            arrays[in] = arrays[in + <span class="number">1</span>];</div><div class="line">            arrays[in + <span class="number">1</span>] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<h3 id="选择排序0-N-2"><a href="#选择排序0-N-2" class="headerlink" title="选择排序0(N^2)"></a>选择排序0(N^2)</h3><p>比较所有的数据项，取出最小值，放左边。比较剩下的数据，取最小，放最左。。。。<br>内层循环中，每一个in的新位置，数据项a[in]和a[min]比较，如果a[in]更小，则min被赋值为in的值，这里只是下标，没交换。到一次内层循环结束，再交换数据项。这样，最小数据项就会一直被放在左边。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span>[] arrays = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span> &#125;;</div><div class="line"><span class="keyword">int</span> out, in, min, nElems = arrays.length;</div><div class="line"><span class="keyword">for</span> (out = <span class="number">0</span>; out &lt; nElems - <span class="number">1</span>; out++) &#123; <span class="comment">// outer loop</span></div><div class="line">    min = out; <span class="comment">// minimum</span></div><div class="line">    <span class="keyword">for</span> (in = out + <span class="number">1</span>; in &lt; nElems; in++) &#123; <span class="comment">// inner loop</span></div><div class="line">        <span class="keyword">if</span> (arrays[in] &lt; arrays[min]) &#123; <span class="comment">// if min greater</span></div><div class="line">            min = in; <span class="comment">// we have a new min</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> temp = arrays[out]; <span class="comment">// swap them</span></div><div class="line">    arrays[out] = arrays[min];</div><div class="line">    arrays[min] = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="插入排序-N-N-1-2-2"><a href="#插入排序-N-N-1-2-2" class="headerlink" title="插入排序 N*(N-1)/2 /2"></a>插入排序 N*(N-1)/2 /2</h3><p>假设左边部分已经排序好了，从某个位置(比如10)开始无序，将10赋值给一临时值，然后和前面的数据比较，如果9位置比10大，就9右移一位，继续和8比较。。。直到到数据的最左边或找到比10位置数据小的某数据，放在它的右边，10位置的数据就排好了。<br>在大多数情况下，插入算法仍然需要0(N^2)的时间，但比冒泡快一倍，比选择排序也还要快一点。经常被用在较复杂的排序算法的最后阶段，例如快速排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span>[] arrays = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span> &#125;;</div><div class="line"><span class="keyword">int</span> in, out, nElems = arrays.length;</div><div class="line"><span class="keyword">for</span> (out = <span class="number">1</span>; out &lt; nElems; out++) &#123; <span class="comment">// out is dividing line</span></div><div class="line">    <span class="keyword">int</span> temp = arrays[out]; <span class="comment">// remove marked item</span></div><div class="line">    in = out; <span class="comment">// start shifts at out</span></div><div class="line">    <span class="keyword">while</span> (in &gt; <span class="number">0</span> &amp;&amp; arrays[in - <span class="number">1</span>] &gt;= temp)<span class="comment">// until one is smaller,</span></div><div class="line">    &#123;</div><div class="line">        arrays[in] = arrays[in - <span class="number">1</span>];<span class="comment">// shift item right</span></div><div class="line">        --in;</div><div class="line">    &#125;</div><div class="line">    arrays[in] = temp; <span class="comment">// insert marked item</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="归并排序O-N-logN"><a href="#归并排序O-N-logN" class="headerlink" title="归并排序O(N logN)"></a>归并排序O(N logN)</h3><p>只要O(N logN)，而冒泡排序，选择排序，插入排序都要用O(N N);.<br>归并排序的思想是：将一个数组分成两半，然后分别排序，然后将数组的两半合并，合并的时候需要比较大小(合并的时候还要考虑两小数组还有没有数据，即有可能一边有，另一边没有)。至于如何排序1/2半的数组，当然是再分成两个1/4数组，再排序。。。直到分割的小数组只有1个数据项，不用排序了。这是用到递归的思想<br>归并排序的缺点，需要在存储器中有另一个大小等于被排序的数据项数目的空间，用来复制分割出来的小数组。<br>归并算法的效率由来：需要复制log<sub>2</sub><sup>N</sup>层(分子数组)，每一个层都是N个数据，所以是NxlogN.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] guibing() &#123;</div><div class="line">    <span class="keyword">int</span>[] arrays = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span> &#125;;</div><div class="line">    <span class="keyword">int</span>[] workSpace = <span class="keyword">new</span> <span class="keyword">int</span>[arrays.length];</div><div class="line">    recMergeSort(arrays, workSpace, <span class="number">0</span>, arrays.length - <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> arrays;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span>[] workPlace, <span class="keyword">int</span> lowPtr, <span class="keyword">int</span> highPtr, <span class="keyword">int</span> upperBound)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// workspace index</span></div><div class="line">    <span class="keyword">int</span> lowerBound = lowPtr;</div><div class="line">    <span class="keyword">int</span> mid = highPtr - <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> n = upperBound - lowerBound + <span class="number">1</span>; <span class="comment">// size of items</span></div><div class="line">    <span class="comment">// 两边都有</span></div><div class="line">    <span class="keyword">while</span> (lowPtr &lt;= mid &amp;&amp; highPtr &lt;= upperBound) &#123;</div><div class="line">        <span class="keyword">if</span> (source[lowPtr] &lt; source[highPtr]) &#123;</div><div class="line">            workPlace[j++] = source[lowPtr++];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            workPlace[j++] = source[highPtr++];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 只有左边</span></div><div class="line">    <span class="keyword">while</span> (lowPtr &lt;= mid) &#123;</div><div class="line">        workPlace[j++] = source[lowPtr++];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 只有右边</span></div><div class="line">    <span class="keyword">while</span> (highPtr &lt;= upperBound) &#123;</div><div class="line">        workPlace[j++] = source[highPtr++];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 把值复制到原对象</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</div><div class="line">        source[lowerBound + j] = workPlace[j];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recMergeSort</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span>[] workSpace, <span class="keyword">int</span> lowerBound, <span class="keyword">int</span> upperBound)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (lowerBound == upperBound) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int</span> mid = (lowerBound + upperBound) / <span class="number">2</span>;</div><div class="line">        recMergeSort(source, workSpace, lowerBound, mid);</div><div class="line">        recMergeSort(source, workSpace, mid + <span class="number">1</span>, upperBound);</div><div class="line">        merge(source, workSpace, lowerBound, mid + <span class="number">1</span>, upperBound);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序基于插入排序，但增加了一个新的特性，大大地提高了插入排序的执行效率。(希尔是个人名。。。)<br>改进的地方：插入算法中，如果一个数据比较小而居于最右边，那么它需要一个一个地移动所有中间的数据项，效率比较低。<br>希尔排序通过加入插入排序中元素之间的间隔，并在这些有间隔的元素中进行插入排序，从而使数据项能大跨度地移动。当这些数据项排过一趟序后，减小数据项的间隔。再进行排序，依次进行下去。间隔被称为增量，用h表示.<br>进行过几次增量排序后，所有的元素离它再最终有序序列中的位置相差不大，数组达到”基本有序”,这时再来插入排序，移动量非常小。<br>当h值很大的时候，数据项每一趟排序需要移动元素的个数很少，但数据项移动的距离很长，这是非常有效率的。当h减少时，每一趟排序需要移动的元素的个数增多，但是此时数据项已经接近于它们排序后最终的位置，这对于插入排序可以更有效率。<br>其中，h = h x 3 +1, h = (h -1) / 3,是经验值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span>[] arrays = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span> &#125;;</div><div class="line"><span class="keyword">int</span> inner, outer, nElems = arrays.length;</div><div class="line"><span class="keyword">int</span> temp;</div><div class="line"><span class="keyword">int</span> h = <span class="number">1</span>;</div><div class="line"><span class="keyword">while</span> (h &lt;= nElems / <span class="number">3</span>) &#123;</div><div class="line">    h = h * <span class="number">3</span> + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">while</span> (h &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (outer = h; outer &lt; nElems; outer++) &#123;</div><div class="line">        temp = arrays[outer];</div><div class="line">        inner = outer;</div><div class="line">        <span class="keyword">while</span> (inner &gt; h - <span class="number">1</span> &amp;&amp; arrays[inner - h] &gt;= temp) &#123;</div><div class="line">            arrays[inner] = arrays[inner - h];</div><div class="line">            inner -= h;</div><div class="line">        &#125;</div><div class="line">        arrays[inner] = temp;</div><div class="line">    &#125;</div><div class="line">    h = (h - <span class="number">1</span>) / <span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="划分算法"><a href="#划分算法" class="headerlink" title="划分算法"></a>划分算法</h3><p>划分是快速排序的根本机制，但是划分本身也是一个有用的操作，这里单讲划分的算法。<br>划分数据就是把数据分为两组，使所有关键字大于特定值的数据项在一组，使所有关键字小于特定值的数据项在另一组。</p>
<p>划分算法由两个指针开始工作，两个指针分别指向数组的两头。在左边的指针，leftPtr，向右移动，而在右边的指针，rightPtr，向左移动。<br>实际上，leftPtr初始化时是在第一个数据项的左边一位(-1)，rightPtr是在最后一个数据项的右边一位(size)，这是因为在工作之前，它们都要分别的加一和减一。<br>停止和交换：当leftPtr遇到比枢纽(特定值，划分值)小的数据项时，它继续右移，因为这个数据项的位置已经处在数组的正确一边了。但是，当遇到比枢纽大的数据项时，它就停下来。类似的，当rightPtr遇到小于枢纽的数据项时，它也停下来。两个内层的while循环，控制这个扫面过程，当两个都停下来时，要么指针到头要么遇到错误的数据(大小比较不对)，做交换(更换位置，正确排列了)。<br>当两个指针最终相遇的时候，划分过程结束，并且推出这个外层的while循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] huafen() &#123;</div><div class="line">    <span class="keyword">int</span>[] arrays = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span> &#125;;</div><div class="line">    sort(arrays, <span class="number">6</span>);</div><div class="line">    <span class="keyword">return</span> arrays;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] ary, <span class="keyword">int</span> base)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> right = ary.length - <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> leftpoint = left, rightpoint = right;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="comment">// 分成左右两边同时进行比较，一边从左向右，一边从右向左，</span></div><div class="line">        <span class="keyword">while</span> (leftpoint &lt; right &amp;&amp; ary[leftpoint++] &lt; base)</div><div class="line">            ; <span class="comment">// leftpoint大于right或ary[leftpoint]&gt;base停止循环</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (rightpoint &gt;= left &amp;&amp; ary[rightpoint--] &gt; base)</div><div class="line">            ; <span class="comment">// 反之</span></div><div class="line">        System.out.println(<span class="string">"左边需要交换的索引:"</span> + (leftpoint - <span class="number">1</span>));</div><div class="line">        System.out.println(<span class="string">"右边需要交换的索引:"</span> + (rightpoint + <span class="number">1</span>));</div><div class="line">        <span class="comment">// 上面拿到了不符合条件的两个索引，即需要交换的两个索引</span></div><div class="line">        <span class="keyword">if</span> (leftpoint - <span class="number">1</span> &lt; rightpoint + <span class="number">1</span>) &#123;<span class="comment">// 需要交换</span></div><div class="line">            <span class="keyword">int</span> temp = ary[leftpoint - <span class="number">1</span>];</div><div class="line">            ary[leftpoint - <span class="number">1</span>] = ary[rightpoint + <span class="number">1</span>];</div><div class="line">            ary[rightpoint + <span class="number">1</span>] = temp;</div><div class="line">            leftpoint = left;</div><div class="line">            rightpoint = right;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>最流行的排序算法，时间复杂度为O(N*logN)。虽然不觉得这种行为好，但有的公司喜欢笔试时让人手写快排(一些开发者如是说)。<br>原理是：把一个数组划分为两个子数组，这里用到划分算法，左子数组的数据项都小于右子数组的数据项，然后递归地调用自身为每个子数组进行快速排序来实现，最后使用插入排序。</p>
<p>在这个算法中划分的关键值(枢纽)的选择非常重要。<br>最初思想，选用数组最右边的值为pivot,进行一次划分，划分的结果就是left-&gt;mid-1, mid-&gt;right-1, right(这个位置的值是pivot)，三部分，然后交换mid和right的值(划分算法的leftPtr在停止时会停在mid位置)，这样pivot就到中间，而小于pivot的值全在左边，大于的值全在右边，数组的排序不受影响。<br>下面的排序从left到pivot-1,pivot+到right。中间项不参与划分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort() &#123;</div><div class="line">    <span class="keyword">int</span>[] arrays = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span> &#125;;</div><div class="line">    qsort(arrays, <span class="number">0</span>, arrays.length - <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> arrays;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</div><div class="line">        <span class="keyword">int</span> pivot = partition(arr, low, high); <span class="comment">// 将数组分为两部分</span></div><div class="line">        qsort(arr, low, pivot - <span class="number">1</span>); <span class="comment">// 递归排序左子数组</span></div><div class="line">        qsort(arr, pivot + <span class="number">1</span>, high); <span class="comment">// 递归排序右子数组</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> pivot = arr[low]; <span class="comment">// 枢轴记录</span></div><div class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</div><div class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot)</div><div class="line">            --high;</div><div class="line">        arr[low] = arr[high]; <span class="comment">// 交换比枢轴小的记录到左端</span></div><div class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot)</div><div class="line">            ++low;</div><div class="line">        arr[high] = arr[low]; <span class="comment">// 交换比枢轴小的记录到右端</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 扫描完成，枢轴到位</span></div><div class="line">    arr[low] = pivot;</div><div class="line">    <span class="comment">// 返回的是枢轴的位置</span></div><div class="line">    <span class="keyword">return</span> low;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>作者 <a href="http://weibo.com/u/2413072655?s_all=1&amp;is_all=1" target="_blank" rel="external">夏目</a><br>2016 年 12月 05日</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;冒泡排序-0-N-2&quot;&gt;&lt;a href=&quot;#冒泡排序-0-N-2&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序 0(N^2)&quot;&gt;&lt;/a&gt;冒泡排序 0(N^2)&lt;/h3&gt;&lt;p&gt;执行非常慢，概念上最简单。最大的会一直被交换，冒泡上来&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] arrays = &amp;#123; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; out, in;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (out = arrays.length - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; out &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; out--) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// outer loop(backward)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (in = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; in &amp;lt; out; in++) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// inter loop(forward)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (arrays[in] &amp;gt; arrays[in + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// out of order&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp = arrays[in]; &lt;span class=&quot;comment&quot;&gt;// swap them&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            arrays[in] = arrays[in + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            arrays[in + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = temp;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="java" scheme="http://haymaicc.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://haymaicc.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>POI 导出大量数据到Excel</title>
    <link href="http://haymaicc.github.io/2016/05/06/poi/"/>
    <id>http://haymaicc.github.io/2016/05/06/poi/</id>
    <published>2016-05-06T05:44:55.000Z</published>
    <updated>2017-05-07T08:27:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做一个excel导出功能的时候，发现一个很严重的性能问题，只能导出4W条，再多不仅特别慢，导不出来，可能还会内存溢出。于是查了下资料，发现是poi 3.8以前的版本不支持大批量数据的导出，<a href="http://poi.apache.org/spreadsheet/how-to.html#sxssf" target="_blank" rel="external">参考官方介绍</a><br>于是将jar包升级后，修改代码，最终能在5分钟内导出100W的数据。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExcelUtil</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleExcel</span><span class="params">()</span></span>&#123;</div><div class="line">		SXSSFWorkbook workbook = <span class="keyword">new</span> SXSSFWorkbook(<span class="number">1000</span>);</div><div class="line">        Sheet sheet = workbook.createSheet();</div><div class="line">		<span class="keyword">try</span></div><div class="line">        &#123;</div><div class="line"></div><div class="line">            Row  hSSFRowHead = sheet.createRow(<span class="number">0</span>);</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; headNames.length; i++)</div><div class="line">			&#123;</div><div class="line">            hSSFCell hSSFCell = hSSFRowHead.createCell(i, HSSFCell.CELL_TYPE_STRING);</div><div class="line">            hSSFCell.setCellValue(<span class="keyword">new</span> XSSFRichTextString(headNames[i]));</div><div class="line">			&#125;</div><div class="line">            List prdList = getExcelDataList();</div><div class="line">			<span class="keyword">for</span> (Object prd : prdList)</div><div class="line">            &#123;</div><div class="line">                Row hSSFRowData = sheet.createRow(count);</div><div class="line">                createDataRows(hSSFRowData, (Map) prd, headsName);</div><div class="line">				Cell hSSFCell;</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; headsName.length; i++)</div><div class="line">				&#123;</div><div class="line">					hSSFCell = hSSFRowData.createCell(i, HSSFCell.CELL_TYPE_STRING);</div><div class="line">					setStringValue(prd, headsName[i], hSSFCell);</div><div class="line">				&#125;</div><div class="line">				<span class="comment">//刷新内存</span></div><div class="line">                <span class="keyword">if</span> (count % <span class="number">1000</span> == <span class="number">0</span>)</div><div class="line">                &#123;</div><div class="line">                    ((SXSSFSheet) sheet).flushRows();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span> (Exception e)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">        &#125;</div><div class="line">        ByteArrayOutputStream ot = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">        workbook.write(ot);</div><div class="line">        <span class="comment">//不调用此方法会在tomcat/temp/poifiles下生成  **.xml文件，并且不会清理，调用清理临时文件</span></div><div class="line">        workbook.dispose();</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做一个excel导出功能的时候，发现一个很严重的性能问题，只能导出4W条，再多不仅特别慢，导不出来，可能还会内存溢出。于是查了下资料，发现是poi 3.8以前的版本不支持大批量数据的导出，&lt;a href=&quot;http://poi.apache.org/spreadsheet/how-to.html#sxssf&quot;&gt;参考官方介绍&lt;/a&gt;&lt;br&gt;于是将jar包升级后，修改代码，最终能在5分钟内导出100W的数据。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://haymaicc.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://haymaicc.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Tips</title>
    <link href="http://haymaicc.github.io/2016/04/09/tips/"/>
    <id>http://haymaicc.github.io/2016/04/09/tips/</id>
    <published>2016-04-09T03:20:12.000Z</published>
    <updated>2017-05-17T05:02:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://haymaicc.github.io/res/tips.png" alt=""></p>
<a id="more"></a>
<p>通过<a href="http://haymai.cc/2016/04/06/hexo/" target="_blank" rel="external">Hexo 安装教程</a>,我们已经能基本使用Hexo了。但是笔者在使用过程中还是遇到了一些问题，在这一篇中希望能总结一些经验，不能说是很有用的东西，也只是希望做一个记录。遇到了能在这里找到解决方法。</p>
<h3 id="代码提交到了Github上"><a href="#代码提交到了Github上" class="headerlink" title="代码提交到了Github上"></a>代码提交到了Github上</h3><p>我把hexo的源码和主题的修改都用<a href="https://github.com/haymaicc/xiamu/tree/master" target="_blank" rel="external">Git提交到了Github上</a>,如果想看本站源码可以down下来，Git具体操作<a href="http://1ke.co/course/194" target="_blank" rel="external">这篇文章</a>介绍的很详细，我也是通过这篇文章Get到套路的。</p>
<h3 id="Node-forever"><a href="#Node-forever" class="headerlink" title="Node forever"></a>Node forever</h3><p>在搭好环境后，我发现有时候莫名其妙的Hexo就挂了，然后整个网站就无法浏览，实际上通过Node forever 就可以解决这个问题，原理就是在后台用定时任务去跑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure></p>
<p>如果挂了就重启。具体怎么做呢？</p>
<blockquote>
<ul>
<li>通过<strong>npm</strong>安装forever</li>
<li>在hexo目录下写好一个javascript脚本</li>
<li>通过forever定时执行该脚本</li>
</ul>
</blockquote>
<p>1、通过<strong>npm</strong>安装forever，执行如下命令安装forever<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo npm install forever -g   #安装</div></pre></td></tr></table></figure></p>
<p>2、在hexo的根目录下新建一个haymai.js文件，内容如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn;</div><div class="line">free = spawn(<span class="string">'hexo'</span>, [<span class="string">'server'</span>, <span class="string">'-p 80'</span>]);</div><div class="line"></div><div class="line">free.stdout.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'standard output:\n'</span> + data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">free.stderr.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123; </div><div class="line"><span class="built_in">console</span>.log(<span class="string">'standard error output:\n'</span> + data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">free.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code, signal</span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'child process eixt ,exit:'</span> + code);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>3、执行如下命令跑定时任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ forever --minUptime 10000 --spinSleepTime 26000 start haymai.js</div></pre></td></tr></table></figure></p>
<h3 id="加入RSS和Sitemap"><a href="#加入RSS和Sitemap" class="headerlink" title="加入RSS和Sitemap"></a>加入RSS和Sitemap</h3><p>1、在Hexo根目录执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-generator-feed</div><div class="line">$ npm install hexo-generator-sitemap</div></pre></td></tr></table></figure></p>
<p>2、在Hexo根目录下加入<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Extensions</span></div><div class="line"><span class="attr">Plugins:</span></div><div class="line"><span class="bullet">-</span> hexo-generator-feed</div><div class="line"><span class="bullet">-</span> hexo-generator-sitemap</div><div class="line"></div><div class="line"><span class="comment">#Feed Atom</span></div><div class="line"><span class="attr">feed:</span></div><div class="line"><span class="attr">  type:</span> atom</div><div class="line"><span class="attr">  path:</span> atom.xml</div><div class="line"><span class="attr">  limit:</span> <span class="number">20</span></div><div class="line"></div><div class="line"><span class="comment">#sitemap</span></div><div class="line"><span class="attr">sitemap:</span></div><div class="line"><span class="attr">  path:</span> sitemap.xml</div></pre></td></tr></table></figure></p>
<p>3、执行hexo clean和hexo deploy 后，打开haymai.cc/atom.xml，haymai.cc/sitemap.xml即可看到已生效</p>
<h3 id="公益404页面"><a href="#公益404页面" class="headerlink" title="公益404页面"></a>公益404页面</h3><p><a href="haymai.cc/aaa">haymai.cc/aaa -&gt; 腾讯公益</a><br>这个真心蛋疼死了，网上大多数人说只要把一个404.html放进source文件夹就行了，但是我放了死活不行，结果找了半天，原来是用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure></p>
<p>启动的不会去跳转到404.html，这不就是说hexo 没有这功能？！ 最终我只好祭出杀手锏，抛弃 hexo启动，转而将public文件夹路径指向了tomcat ROOT应用，然后配置ROOT下的web.xml如下内容：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>当然source下的404.html 也要加上，这里用了腾旭公益404页面，内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">layout: false</div><div class="line">title: &quot;404&quot;</div><div class="line">---</div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt;</div><div class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;</div><div class="line">  &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt;</div><div class="line">  &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;http://www.haymai.cc&quot; homePageName=&quot;回到唐伯虎点蜡烛&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>不知道各位看官是怎么解决的，有没有更好的方法？</p>
<h3 id="网易云音乐引入"><a href="#网易云音乐引入" class="headerlink" title="网易云音乐引入"></a>网易云音乐引入</h3><p>哈哈，网站第一次发声，链的网易云，在页面上加入如下代码，你也能听我的红心啦~23333</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div style=&quot;max-width: 350px;max-height: 150px&quot;&gt;</div><div class="line">&lt;embed style=&quot;margin-top: -35px;&quot; frameborder=&quot;no&quot; border=&quot;0&quot;marginwidth=&quot;0&quot; marginheight=&quot;0&quot; src=&quot;https://music.163.com/outchain/player?type=0&amp;id=28560713&amp;auto=0&amp;height=90&quot;&gt;&lt;/embed&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<div style="max-width: 350px;max-height: 150px"><br><embed style="margin-top: -35px;" frameborder="no" border="0" marginwidth="0" marginheight="0" src="https://music.163.com/outchain/player?type=0&id=28560713&auto=1&height=90"><br></div>

<p>作者 <a href="http://weibo.com/u/2413072655?s_all=1&amp;is_all=1" target="_blank" rel="external">夏目</a><br>2016 年 04月 09日</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://haymaicc.github.io/res/tips.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://haymaicc.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://haymaicc.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 安装教程</title>
    <link href="http://haymaicc.github.io/2016/04/06/hexo/"/>
    <id>http://haymaicc.github.io/2016/04/06/hexo/</id>
    <published>2016-04-06T09:16:24.000Z</published>
    <updated>2017-05-07T13:36:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>近来觉得需要一隅来发发牢骚，于是用Hexo搭建了这个博客。</p>
<p><img src="http://i.v2ex.co/5bb7J7NT.png" alt=""></p>
<a id="more"></a>
<p><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo官网</a>介绍的很酷炫，实际上用起来也让我觉得很强大，但是开发文档编写的相当羞涩，所以在这总结一下Hexo的安装教程，希望对大家有所帮助。</p>
<p>首先要想使用Hexo,有两个先决条件：</p>
<blockquote>
<p>安装Git(可以通过GitHub down 一些主题，还有一些源码)<br>安装node.js</p>
</blockquote>
<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>这个相当简单，通过 <a href="https://git-scm.com/download/linux/" target="_blank" rel="external">Git linux命令即可安装</a> ，但是笔者的用的阿里云suse版本的linux，使用Git官网的zypper软件源</p>
<pre><code>$ zypper install git</code></pre>

<p>安装不成功，遂在网上下载了源码，解压安装。</p>
<h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>安装 <a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a> </p>
<pre><code>$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh | bash</code></pre>
CURL安装node
<pre><code>$ curl https://raw.github.com/creationix/nvm/master/install.sh| sh</code></pre>
重启终端并执行下列命令即可安装 Node.js。
<pre><code>$ nvm install 4</code></pre>

<h3 id="所有必备的应用程序安装完成后，即可使用npm安装Hexo。"><a href="#所有必备的应用程序安装完成后，即可使用npm安装Hexo。" class="headerlink" title="所有必备的应用程序安装完成后，即可使用npm安装Hexo。"></a>所有必备的应用程序安装完成后，即可使用npm安装Hexo。</h3><p>如果第一条命令失败，可以试试 –unsafe那条命令安装。</p>
<pre><code>$ npm install -g hexo-cli
$ npm install --unsafe-perm -g hexo-cli</code></pre>

<h3 id="Hexo-基本操作"><a href="#Hexo-基本操作" class="headerlink" title="Hexo 基本操作"></a>Hexo 基本操作</h3><p>到这里Hexo的运行环境基本搭建完成，若是在安装过程中遇到一些依赖包找不到的情况，再用npm安装一些依赖包。<br>Hexo的简单操作，可以看官网的命令介绍 <a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="external">Hexo指令</a><br>通过</p>
<pre><code>$ hexo init [folder]</code></pre>
建立网站，folder就是hexo 要安装的文件夹，若不指定则在当前目录建立。值得一提的是在Hexo安装目录下有个_config.yml文件，可以配置Hexo的一些基本参数，如网站的标题什么的。
然后通过 
<pre><code>$ hexo new [layout]</code></pre>

<p>新建文章，layout默认有三种：post、page 和 draft，存在source/_posts 文件夹。<br>执行完new 命令会生成一个 xxx.md 文件，通过markdown来编写文章，附上 <a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">markdown在线编辑器</a></p>
<p>还有几个常用的 <strong>命令</strong></p>
<pre><code>$ hexo clean
$ hexo generate
$ hexo server -p 80</code></pre>

<p>用来清理和生成静态文件，以固定端口启动hexo</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>[1]:<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">Hexo Themes 主题下载</a>,通过如下命令下载到主题文件夹</p>
<pre><code>git clone git://github.com/SuperKieran/TKL [folder]</code></pre>
[2]:查看Hexo 进程
<pre><code>ps -aux | grep hexo</code></pre>


<hr>
<p>再一次感谢您花费时间阅读，祝您在这里记录、阅读、分享愉快！</p>
<p>作者 <a href="http://weibo.com/u/2413072655?s_all=1&amp;is_all=1" target="_blank" rel="external">夏目</a><br>2016 年 04月 06日</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近来觉得需要一隅来发发牢骚，于是用Hexo搭建了这个博客。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.v2ex.co/5bb7J7NT.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://haymaicc.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://haymaicc.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
