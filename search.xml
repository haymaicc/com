<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[《深入理解java虚拟机》读书笔记(一)]]></title>
      <url>/2017/12/05/jvm1/</url>
      <content type="html"><![CDATA[<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><blockquote>
<p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（Java SE 7版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域：</p>
</blockquote>
<a id="more"></a>
<p><img src="https://haymaicc.github.io/res/jvm1.png" alt=""></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><blockquote>
<p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p>
</blockquote>
<p>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><blockquote>
<p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame[1]）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
</blockquote>
<p>在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><blockquote>
<p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p>
</blockquote>
<p>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><blockquote>
<p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
</blockquote>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote>
<p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
</blockquote>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><blockquote>
<p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
</blockquote>
<h2 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h2><h3 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><blockquote>
<p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
</blockquote>
<p>它很难解决对象之间相互循环引用的问题。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><blockquote>
<p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p>
</blockquote>
<p>在Java语言中，可作为GC Roots的对象包括下面几种：<br>1、虚拟机栈（栈帧中的本地变量表）中引用的对象。<br>2、方法区中类静态属性引用的对象。<br>3、方法区中常量引用的对象。<br>4、本地方法栈中JNI（即一般说的Native方法）引用的对象。</p>
<h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法。当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize（）方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize（）方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize（）中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。</p>
<p><code>建议大家尽量避免使用它，因为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序</code></p>
<h3 id="无用的类"><a href="#无用的类" class="headerlink" title="无用的类"></a>无用的类</h3><p>类需要同时满足下面3个条件才能算是“无用的类”：<br>1、该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。<br>2、加载该类的ClassLoader已经被回收。<br>3、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><blockquote>
<p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p>
</blockquote>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><blockquote>
<p>如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
</blockquote>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><blockquote>
<p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点</p>
</blockquote>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><blockquote>
<p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如图所示。</p>
</blockquote>
<h3 id="内存分配规则"><a href="#内存分配规则" class="headerlink" title="内存分配规则"></a>内存分配规则</h3><h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><blockquote>
<p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p>
</blockquote>
<p><code>新生代GC（Minor GC）</code><br>指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p>
<p><code>老年代GC（Major GC/Full GC）</code><br>指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC。Major GC的速度一般会比Minor GC慢10倍以上。</p>
<h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><blockquote>
<p>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p>
</blockquote>
<h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。</p>
<h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><blockquote>
<p>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
</blockquote>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><blockquote>
<p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JMS & ActiveMQ 简介]]></title>
      <url>/2017/06/04/jms/</url>
      <content type="html"><![CDATA[<h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><blockquote>
<p>Java消息服务（Java Message Service，JMS）应用程序接口是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。</p>
</blockquote>
<a id="more"></a>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>消息传送机制具有以下优点：<br>1）可以实现异构集成，不同平台、不同语言的系统可以通过消息进行通信，实现集成。例如，ActiveMQ支持多语言，除Java以外，还包括C、PHP、Python。<br>2）可以缓解系统瓶颈，当系统同步处理的请求数量增大时，会造成请求阻塞，如果使用消息传送机制，可以将请求以消息方式发送至消息服务器，并由多个请求处理模块接收消息进行并发处理。<br>3）可以提高可伸缩性，这个与缓解系统瓶颈类似，通过增加或减少消息接收者来控制并发处理的能力，提高可伸缩性。<br>4）可以提高最终用户生产率，这是因为使用消息传送机制时，可以对请求进行异步处理，请求以消息方式发送至消息服务器后，最终用户无需同步等待请求返回结果。<br>5）体系结构灵活性和敏捷性，我们知道系统设计的一个基本原则就是高内聚、低耦合，通过引入消息传送机制，各系统服务以消息的形式抽象出来，减少系统之间的耦合，提高系统结构灵活性和敏捷性。</p>
<h3 id="JMS中的角色"><a href="#JMS中的角色" class="headerlink" title="JMS中的角色"></a>JMS中的角色</h3><p>JMS由以下元素组成：</p>
<h4 id="JMS提供者"><a href="#JMS提供者" class="headerlink" title="JMS提供者"></a>JMS提供者</h4><p>连接面向消息中间件的，JMS接口的一个实现。提供者可以是Java平台的JMS实现，也可以是非Java平台的面向消息中间件的适配器。</p>
<h4 id="JMS客户"><a href="#JMS客户" class="headerlink" title="JMS客户"></a>JMS客户</h4><p>生产或消费消息的基于Java的应用程序或对象。</p>
<h4 id="JMS生产者"><a href="#JMS生产者" class="headerlink" title="JMS生产者"></a>JMS生产者</h4><p>创建并发送消息的JMS客户。</p>
<h4 id="JMS消费者"><a href="#JMS消费者" class="headerlink" title="JMS消费者"></a>JMS消费者</h4><p>接收消息的JMS客户。</p>
<h4 id="JMS消息"><a href="#JMS消息" class="headerlink" title="JMS消息"></a>JMS消息</h4><p>包括可以在JMS客户之间传递的数据的对象</p>
<h4 id="JMS队列"><a href="#JMS队列" class="headerlink" title="JMS队列"></a>JMS队列</h4><p>一个容纳那些被发送的等待阅读的消息的区域。队列暗示，这些消息将按照顺序发送。一旦一个消息被阅读，该消息将被从队列中移走。</p>
<h4 id="JMS主题"><a href="#JMS主题" class="headerlink" title="JMS主题"></a>JMS主题</h4><p>一种支持发送消息给多个订阅者的机制。</p>
<h3 id="JMS模型"><a href="#JMS模型" class="headerlink" title="JMS模型"></a>JMS模型</h3><p>Java消息服务应用程序结构支持两种模型：<br>1.点对点或队列模型<br>2.发布/订阅模型</p>
<h4 id="点对点或队列模型"><a href="#点对点或队列模型" class="headerlink" title="点对点或队列模型"></a>点对点或队列模型</h4><blockquote>
<p>在点对点或队列模型下，一个生产者向一个特定的队列发布消息，一个消费者从该队列中读取消息。这里，生产者知道消费者的队列，并直接将消息发送到消费者的队列。</p>
</blockquote>
<p>这种模式被概括为：<br>1）只有一个消费者将获得消息<br>2）生产者不需要在接收者消费该消息期间处于运行状态，接收者也同样不需要在消息发送时处于运行状态。<br>3）每一个成功处理的消息都由接收者签收</p>
<h4 id="点对点或队列模型-1"><a href="#点对点或队列模型-1" class="headerlink" title="点对点或队列模型"></a>点对点或队列模型</h4><blockquote>
<p>发布者／订阅者模型支持向一个特定的消息主题发布消息。0或多个订阅者可能对接收来自特定消息主题的消息感兴趣。在这种模型下，发布者和订阅者彼此不知道对方。这种模式好比是匿名公告板。</p>
</blockquote>
<p>这种模式被概括为：<br>1）多个消费者可以获得消息<br>2）在发布者和订阅者之间存在时间依赖性。发布者需要建立一个订阅（subscription），以便客户能够购订阅。订阅者必须保持持续的活动状态以接收消息，除非订阅者建立了持久的订阅。在那种情况下，在订阅者未连接时发布的消息将在订阅者重新连接时重新发布</p>
]]></content>
      
        <categories>
            
            <category> ActiveMQ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ActiveMQ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java 集合总结]]></title>
      <url>/2017/05/30/java-collections/</url>
      <content type="html"><![CDATA[<p>摘自<a href="http://calvin1978.blogcn.com/articles/collection.html" target="_blank" rel="external">关于Java集合的小抄</a>，供自己学习</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组。因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。<br>按数组下标访问元素－get(i)、set(i,e) 的性能很高，这是数组的基本优势。<br>如果按下标插入元素、删除元素－add(i,e)、 remove(i)、remove(e)，则要用System.arraycopy()来复制移动部分受影响的元素，性能就变差了。<br>越是前面的元素，修改时要移动的元素越多。直接在数组末尾加入元素－常用的add(e)，删除最后一个元素则无影响。</p>
<a id="more"></a>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>以双向链表实现。链表无容量限制，但双向链表本身使用了更多空间，每插入一个元素都要构造一个额外的Node对象，也需要额外的链表指针操作。<br>按下标访问元素－get(i)、set(i,e) 要悲剧的部分遍历链表将指针移动到位 (如果i&gt;数组大小的一半，会从末尾移起)。<br>插入、删除元素时修改前后节点的指针即可，不在需要复制移动。但还是要部分遍历链表的指针才能移动到下标所指的位置。<br>只有在链表两头的操作－add()、addFirst()、removeLast()或用iterator()上的remove()倒能省掉指针的移动。<br>Apache Commons 有个TreeNodeList，里面是棵二叉树，可以快速移动指针到位。</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>并发优化的ArrayList。基于不可变对象策略，在修改时先复制出一个数组快照来修改，改好了，再让内部指针指向新数组。<br>因为对快照的修改对读操作来说不可见，所以读读之间不互斥，读写之间也不互斥，只有写写之间要加锁互斥。但复制快照的成本昂贵，典型的适合读多写少的场景。<br>虽然增加了addIfAbsent(e)方法，会遍历数组来检查元素是否已存在，性能可想像的不会太好。</p>
<h3 id="遗憾"><a href="#遗憾" class="headerlink" title="遗憾"></a>遗憾</h3><p>无论哪种实现，按值返回下标contains(e), indexOf(e), remove(e) 都需遍历所有元素进行比较，性能可想像的不会太好。<br>没有按元素值排序的SortedList。<br>除了CopyOnWriteArrayList，再没有其他线程安全又并发优化的实现如ConcurrentLinkedList。凑合着用Set与Queue中的等价类时，会缺少一些List特有的方法如get(i)。如果更新频率较高，或数组较大时，还是得用Collections.synchronizedList(list)，对所有操作用同一把锁来保证线程安全。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>以Entry[]数组实现的哈希桶数组，用Key的哈希值取模桶数组的大小可得到数组下标。<br>插入元素时，如果两条Key落在同一个桶(比如哈希值1和17取模16后都属于第一个哈希桶)，我们称之为哈希冲突。<br>JDK的做法是链表法，Entry用一个next属性实现多个Entry以单向链表存放。查找哈希值为17的key时，先定位到哈希桶，然后链表遍历桶里所有元素，逐个比较其Hash值然后key值。<br>在JDK8里，新增默认为8的閥值，当一个桶里的Entry超过閥值，就不以单向链表而以红黑树来存放以加快Key的查找速度。<br>当然，最好还是桶里只有一个元素，不用去比较。所以默认当Entry数量达到桶数量的75%时，哈希冲突已比较严重，就会成倍扩容桶数组，并重新分配所有原来的Entry。扩容成本不低，所以也最好有个预估值。<br>取模用与操作(hash &amp; (arrayLength-1))会比较快，所以数组的大小永远是2的N次方， 你随便给一个初始值7会转为3比如12。默认第一次放入元素时的初始值是16。<br>iterator()时顺着哈希桶数组来遍历，看起来是个乱序。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>扩展HashMap，每个Entry增加双向链表，号称是最占内存的数据结构。<br>支持iterator()时按Entry的插入顺序来排序(如果设置accessOrder属性为true，则所有读写访问都排序)。<br>插入时，Entry把自己加到Header Entry的前面去。如果所有读写访问都要排序，还要把前后Entry的before/after拼接起来以在链表中删除掉自己，所以此时读操作也是线程不安全的了。</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>以红黑树实现，红黑树又叫自平衡二叉树：<br>对于任一节点而言，其到叶节点的每一条路径都包含相同数目的黑结点。<br>上面的规定，使得树的层数不会差的太远，使得所有操作的复杂度不超过 O（lgn），但也使得插入，修改时要复杂的左旋右旋来保持树的平衡。<br>支持iterator()时按Key值排序，可按实现了Comparable接口的Key的升序排序，或由传入的Comparator控制。可想象的，在树上插入/删除元素的代价一定比HashMap的大。<br>支持SortedMap接口，如firstKey()，lastKey()取得最大最小的key，或sub(fromKey, toKey), tailMap(fromKey)剪取Map的某一段。</p>
<h3 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h3><p>EnumMap的原理是，在构造函数里要传入枚举类，那它就构建一个与枚举的所有值等大的数组，按Enum. ordinal()下标来访问数组。性能与内存占用俱佳。<br>美中不足的是，因为要实现Map接口，而 V get(Object key)中key是Object而不是泛型K，所以安全起见，EnumMap每次访问都要先对Key进行类型判断，在JMC里录得不低的采样命中频率。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>并发优化的HashMap。<br>在JDK7里的经典设计，默认16把写锁(可以设置更多)，有效分散了阻塞的概率。数据结构为Segment[]，每个Segment一把锁。Segment里面才是哈希桶数组。Key先算出它在哪个Segment里，再去算它在哪个哈希桶里。<br>也没有读锁，因为put/remove动作是个原子动作(比如put的整个过程是一个对数组元素/Entry 指针的赋值操作)，读操作不会看到一个更新动作的中间状态。<br>但在JDK8里，Segment[]的设计被抛弃了，改为精心设计的，只在需要锁的时候加锁。<br>支持ConcurrentMap接口，如putIfAbsent(key，value)与相反的replace(key，value)与以及实现CAS的replace(key, oldValue, newValue)。</p>
<h3 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h3><p>JDK6新增的并发优化的SortedMap，以SkipList结构实现。Concurrent包选用它是因为它支持基于CAS的无锁算法，而红黑树则没有好的无锁算法。<br>原理上，可以想象为多个链表组成的N层楼，其中的元素从稀疏到密集，每个元素有往右与往下的指针。从第一层楼开始遍历，如果右端的值比期望的大，那就往下走一层，继续往前走。<br>典型的空间换时间。每次插入，都要决定在哪几层插入，同时，要决定要不要多盖一层楼。<br>它的size()同样不能随便调，会遍历来统计。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>所有Set几乎都是内部用一个Map来实现, 因为Map里的KeySet就是一个Set，而value是假值，全部使用同一个Object即可。<br>Set的特征也继承了那些内部的Map实现的特征。<br>HashSet：内部是HashMap。<br>LinkedHashSet：内部是LinkedHashMap。<br>TreeSet：内部是TreeMap的SortedSet。<br>ConcurrentSkipListSet：内部是ConcurrentSkipListMap的并发优化的SortedSet。<br>CopyOnWriteArraySet：内部是CopyOnWriteArrayList的并发优化的Set，利用其addIfAbsent()方法实现元素去重，如前所述该方法的性能很一般。<br>好像少了个ConcurrentHashSet，本来也该有一个内部用ConcurrentHashMap的简单实现，但JDK偏偏没提供。Jetty就自己简单封了一个，Guava则直接用java.util.Collections.newSetFromMap(new ConcurrentHashMap()) 实现。</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><blockquote>
<p>Queue是在两端出入的List，所以也可以用数组或链表来实现。</p>
</blockquote>
<h3 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h3><h4 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>是的，以双向链表实现的LinkedList既是List，也是Queue。</p>
<h4 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h4><p>以循环数组实现的双向Queue。大小是2的倍数，默认是16。<br>为了支持FIFO，即从数组尾压入元素（快），从数组头取出元素（超慢），就不能再使用普通ArrayList的实现了，改为使用循环数组。<br>有队头队尾两个下标：弹出元素时，队头下标递增；加入元素时，队尾下标递增。如果加入元素时已到数组空间的末尾，则将元素赋值到数组[0]，同时队尾下标指向0，再插入下一个元素则赋值到数组[1]，队尾下标指向1。如果队尾的下标追上队头，说明数组所有空间已用完，进行双倍的数组扩容。</p>
<h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>用平衡二叉最小堆实现的优先级队列，不再是FIFO，而是按元素实现的Comparable接口或传入Comparator的比较结果来出队，数值越小，优先级越高，越先出队。但是注意其iterator()的返回不会排序。<br>平衡最小二叉堆，用一个简单的数组即可表达，可以快速寻址，没有指针什么的。最小的在queue[0] ，比如queue[4]的两个孩子，会在queue[2<em>4+1] 和 queue[2</em>(4+1)]，即queue[9]和queue[10]。<br>入队时，插入queue[size]，然后二叉地往上比较调整堆。<br>出队时，弹出queue[0]，然后把queque[size]拿出来二叉地往下比较调整堆。<br>初始大小为11，空间不够时自动50%扩容。</p>
<h3 id="线程安全的队列"><a href="#线程安全的队列" class="headerlink" title="线程安全的队列"></a>线程安全的队列</h3><h4 id="ConcurrentLinkedQueue-Deque"><a href="#ConcurrentLinkedQueue-Deque" class="headerlink" title="ConcurrentLinkedQueue/Deque"></a>ConcurrentLinkedQueue/Deque</h4><p>无界的并发优化的Queue，基于链表，实现了依赖于CAS的无锁算法。<br>ConcurrentLinkedQueue的结构是单向链表和head/tail两个指针，因为入队时需要修改队尾元素的next指针，以及修改tail指向新入队的元素两个CAS动作无法原子，所以需要的特殊的算法。</p>
<h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>无界的PriorityQueue，也是基于数组存储的二叉堆。一把公共的锁实现线程安全。虽然实现了BlockingQueue接口，但因为无界，其实没有任何阻塞队列的特征，空间不够时会自动扩容。</p>
<h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>内部包含一个PriorityQueue，同样是无界的。一把公共的锁实现线程安全。元素需实现Delayed接口，每次调用时需返回当前离触发时间还有多久，小于0表示该触发了。<br>pull()时会用peek()查看队头的元素，检查是否到达触发时间。ScheduledThreadPoolExecutor用了类似的结构。</p>
<h3 id="线程安全的阻塞队列"><a href="#线程安全的阻塞队列" class="headerlink" title="线程安全的阻塞队列"></a>线程安全的阻塞队列</h3><p>BlockingQueue的队列长度受限，用以保证生产者与消费者的速度不会相差太远，避免内存耗尽。队列长度设定后不可改变。当入队时队列已满，或出队时队列已空，不同函数的效果见下表：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">立刻报异常</th>
<th style="text-align:center">立刻返回布尔</th>
<th style="text-align:center">阻塞等待</th>
<th>可设定等待时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">入队</td>
<td style="text-align:center">add(e)</td>
<td style="text-align:center">offer(e)</td>
<td style="text-align:center">put(e)</td>
<td>offer(e, timeout, unit)</td>
</tr>
<tr>
<td style="text-align:center">出队</td>
<td style="text-align:center">remove()</td>
<td style="text-align:center">poll()</td>
<td style="text-align:center">take()</td>
<td>poll(timeout, unit)</td>
</tr>
<tr>
<td style="text-align:center">查看</td>
<td style="text-align:center">element()</td>
<td style="text-align:center">peek()</td>
<td style="text-align:center">无</td>
<td>无</td>
</tr>
</tbody>
</table>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>定长的并发优化的BlockingQueue，也是基于循环数组实现。有一把公共的锁与notFull、notEmpty两个Condition管理队列满或空时的阻塞状态。</p>
<h4 id="LinkedBlockingQueue-Deque"><a href="#LinkedBlockingQueue-Deque" class="headerlink" title="LinkedBlockingQueue/Deque"></a>LinkedBlockingQueue/Deque</h4><p>可选定长的并发优化的BlockingQueue，基于链表实现，所以可以把长度设为Integer.MAX_VALUE成为无界无等待的。<br>利用链表的特征，分离了takeLock与putLock两把锁，继续用notEmpty、notFull管理队列满或空时的阻塞状态。</p>
<h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>SynchronousQueue同步队列本身无容量，放入元素时，比如等待元素被另一条线程的消费者取走再返回。JDK线程池里用它。<br>JDK7还有个LinkedTransferQueue，在普通线程安全的BlockingQueue的基础上，增加一个transfer(e) 函数，效果与SynchronousQueue一样。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Mvc (一)]]></title>
      <url>/2017/05/30/springmvc1/</url>
      <content type="html"><![CDATA[<p>本文摘自<a href="http://downpour.iteye.com/blog/1330537" target="_blank" rel="external">SpringMVC深度探险</a>系列。</p>
<h2 id="从大的角度来看Spring-Mvc"><a href="#从大的角度来看Spring-Mvc" class="headerlink" title="从大的角度来看Spring Mvc"></a>从大的角度来看Spring Mvc</h2><p>B／S模型解决的实际问题是请求—响应，其中不外乎两个角色，服务方和请求方。因而也就产生了两种截然不同的针对表示层的解决方案的设计思路：<br><code>以服务器端应用程序为主导来进行框架设计</code><br><code>以浏览器页面组件（及其自身的事件触发模型）为主导来进行框架设计</code><br>前一种被称之为MVC模型；后一种则被称之为组件模型，也有称之为事件模型。</p>
<a id="more"></a>
<h2 id="MVC模型"><a href="#MVC模型" class="headerlink" title="MVC模型"></a>MVC模型</h2><p>我们选取当前比较热门的两大框架Struts2和SpringMVC作为代码示例<br>首先，我们将用户注册场景中最为核心的“用户类”定义出来：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;  </div><div class="line">   <span class="keyword">private</span> String email;  </div><div class="line">   <span class="keyword">private</span> String password;  </div><div class="line">   <span class="comment">// 省略了setter和getter方法  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>紧接着是一个简单的JSP表单：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"/register"</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Email:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"email"</span> /&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Password:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> /&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"submit"</span> /&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>上述这两段代码无论是SpringMVC还是Struts2，都可以共用。而在请求响应处理类（也就是Controller）上的设计差异是两个框架最大的不同。<br>如果使用SpringMVC，那么Controller的代码看上去就像这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span>  </div><div class="line"><span class="meta">@RequestMapping</span>  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;  </div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/register"</span>)  </div><div class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">register</span><span class="params">(String email, String password)</span> </span>&#123;  </div><div class="line">    <span class="comment">// 在这里调用具体的业务逻辑代码  </span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"register-success"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果使用Struts2，那么Controller的代码看上去就稍有不同：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;  </div><div class="line">     <span class="keyword">private</span> String email;  </div><div class="line">     <span class="keyword">private</span> String password;  </div><div class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">()</span> </span>&#123;  </div><div class="line">         <span class="comment">// 在这里调用具体的业务逻辑代码  </span></div><div class="line">         <span class="keyword">return</span> <span class="string">"register-success"</span>;  </div><div class="line">     &#125;  </div><div class="line">    <span class="comment">// 这里省略了setter和getter方法  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>除此之外，Struts2还需要在某个配置文件中进行请求映射的配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"register"</span> <span class="attr">class</span>=<span class="string">"com.demo2do.sandbox.web.UserController"</span> <span class="attr">method</span>=<span class="string">"register"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/register-success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>框架本身并不通过某种手段来干预或者控制浏览器发送Http请求的行为方式。 </p>
</blockquote>
<p>从上面的代码中我们就可以看到，无论是SpringMVC还是Struts2，它们在请求页面的实现中都使用了原生HTML代码。就算是Http请求的发送，也借助于HTML之中对Form提交请求的支持。</p>
<h3 id="MVC框架的一些普遍特征"><a href="#MVC框架的一些普遍特征" class="headerlink" title="MVC框架的一些普遍特征"></a>MVC框架的一些普遍特征</h3><blockquote>
<p>框架本身并不通过某种手段来干预或者控制浏览器发送Http请求的行为方式。</p>
</blockquote>
<p>从上面的代码中我们就可以看到，无论是SpringMVC还是Struts2，它们在请求页面的实现中都使用了原生HTML代码。就算是Http请求的发送，也借助于HTML之中对Form提交请求的支持</p>
<blockquote>
<p>页面（View层）和请求处理类（Controller）之间的映射关系通过某一种配置形式维系起来。</p>
</blockquote>
<p>我们可以看到在浏览器和Web服务器之间的映射关系在不同的框架中被赋予了不同的表现形式：在SpringMVC中，使用了Annotation注解；在Struts2中，默认采取XML配置文件。不过无论是哪一种配置形式，隐藏在其背后的都是对于请求映射关系的定义。</p>
<blockquote>
<p>Controller层的设计差异是不同MVC框架之间最主要的差异。 </p>
</blockquote>
<p>这一点实际上是我们在对于MVC模型自身进行定义时就反复强调的一点。在上面的例子中，我们可以看到SpringMVC使用<code>方法参数</code>来对请求的数据进行映射；而Struts2使用Controller类<code>内部的属性</code>来进行数据请求的映射。 </p>
<p>在MVC模型中，浏览器端和服务器端的交互关系非常明确：无论采取什么样的框架，<code>总是以一个明确的URL作为中心，辅之以参数请求</code>。因此，URL看上去就像是一个明文的契约，当然，真正蕴藏在背后的是Http协议。所有的这些东西都被放在了台面上，我们可以非常明确地获取到一次交互中所有的Http信息。这也是MVC模型中最为突出的一个特点。 </p>
<h2 id="组件模型"><a href="#组件模型" class="headerlink" title="组件模型"></a>组件模型</h2><p>在组件模型中，我们则选取较为成熟的Tapestry5作为我们的代码示例。<br>首先，我们来看看请求页面的情况：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">t:type</span>=<span class="string">"form"</span> <span class="attr">t:id</span>=<span class="string">"form"</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">t:label</span> <span class="attr">for</span>=<span class="string">"email"</span>/&gt;</span>:<span class="tag">&lt;<span class="name">input</span> <span class="attr">t:type</span>=<span class="string">"TextField"</span> <span class="attr">t:id</span>=<span class="string">"email"</span> <span class="attr">t:validate</span>=<span class="string">"required,minlength=3"</span> <span class="attr">size</span>=<span class="string">"30"</span>/&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">t:label</span> <span class="attr">for</span>=<span class="string">"password"</span>/&gt;</span>:<span class="tag">&lt;<span class="name">input</span> <span class="attr">t:type</span>=<span class="string">"PasswordField"</span> <span class="attr">t:id</span>=<span class="string">"password"</span> <span class="attr">t:validate</span>=<span class="string">"required,minlength=3"</span> <span class="attr">size</span>=<span class="string">"30"</span>/&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Login"</span>/&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在这里，请求的页面不再是原生的HTML代码，而是一个扩展后的HTML，这一扩展包含了对HTML标签的扩展（增加了新的标签，例如<t:label>），也包含了对HTML自身标签中属性的扩展（增加新的支持属性，例如t:type，t:validate）。<br>接着我们来看看服务器端响应程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Register</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> String email;  </div><div class="line">    <span class="keyword">private</span> String password;  </div><div class="line">    </div><div class="line">    <span class="meta">@Component</span>(id = <span class="string">"password"</span>)  </div><div class="line">    <span class="keyword">private</span> PasswordField passwordField;  </div><div class="line">  </div><div class="line">    <span class="meta">@Component</span>  </div><div class="line">    <span class="keyword">private</span> Form form;  </div><div class="line">  </div><div class="line">    <span class="function">String <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="string">"PostRegister"</span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">// 这里省略了setter和getter方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></t:label></p>
<h3 id="与MVC框架相比较"><a href="#与MVC框架相比较" class="headerlink" title="与MVC框架相比较"></a>与MVC框架相比较</h3><p>从上面的代码示例中，我们可以看到一些与MVC模型截然不同的特点： </p>
<blockquote>
<p>框架通过对HTML进行行为扩展来干预和控制浏览器与服务器的交互过程。 </p>
</blockquote>
<p>我们可以发现，Tapestry5的请求页面被加入了更多的HTML扩展，这些扩展包括对HTML标签的扩展以及HTML标签中属性的扩展。而这些扩展中，有不少直接干预了浏览器与服务器的交互。例如，上面例子中的t:validate=”required,minlength=3”扩展实际上就会被自动映射到服务器端程序中带有@Component(id=”password”)标注的PasswordField组件上，并在提交时自动进行组件化校验。而当页面上的提交按钮被点击触发时，默认在服务器端的onSuccess方法会形成响应并调用其内部逻辑。 </p>
<blockquote>
<p>页面组件的实现是整个组件模型的绝对核心</p>
</blockquote>
<p>从上述的例子中，我们可以看到组件模型的实现不仅需要服务器端实现，还需要在页面上指定与某个特定组件进行事件绑定。两者缺一不可，必须相互配合，共同完成。因此整个Web程序的交互能力完全取决于页面组件的实现好坏。 </p>
<blockquote>
<p>页面组件与服务器端响应程序之间的映射契约并不基于Http协议进行</p>
</blockquote>
<p>在上面的例子中，从页面组件到服务器端的响应程序之间的映射关系是通过名称契约而定的。而页面上的每个组件可以指定映射到服务器端程序的具体某一个方法。我们可以看到这种映射方式并不是一种基于URL或者Http协议的映射方式，而是一种命名指定的方式。<br>在组件模型中，浏览器端和服务器端的交互关系并不以一个具体的URL为核心，我们在上述的例子中甚至完全没有看到任何URL的影子。不过这种事件响应式的方式，也提供给我们另外一个编程的思路，而这种基于契约式的请求-响应映射也得到了一部分程序员的喜爱。因而组件模型的粉丝数量也是很多的。 </p>
<h2 id="MVC模型的各种形态"><a href="#MVC模型的各种形态" class="headerlink" title="MVC模型的各种形态"></a>MVC模型的各种形态</h2><p>之前我们已经谈到，MVC模型是一种以服务器响应程序（也就是Controller）为核心进行程序设计的，因而所有的MVC框架的历史发展进程实际上是一个围绕着Controller不断进行重构和改造的过程。而在这个过程中，不同的MVC框架也就表现出了不同的表现形态。接下来，我们就给出一些具有代表意义的MVC框架表现形态。</p>
<h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><blockquote>
<p>Servlet是MVC模型最为基本的表现形态。</p>
</blockquote>
<p>Servlet的基本接口定义中： </p>
<p><code>参数列表</code> —— Http请求被封装为一个HttpServletRequest对象（或者ServletRequest对象），而Http响应封装为一个HttpServletResponse对象（或者ServletResponse对象）<br><code>返回值</code> —— 方法不存在返回值（返回值为void）<br>在这个设计中，HttpServletRequest和HttpServletResponse承担了完整的处理Http请求的任务。而这两个Servlet对象的职责也有所分工：<br><code>HttpServletRequest对象</code> —— 主要用于处理整个Http生命周期中的数据。<br><code>HttpServletResponse对象</code> —— 主要用于处理Http的响应结果。</p>
<blockquote>
<p>MVC模型的这一种形态，被笔者冠以一个名称：<code>参数-参数（Param-Param）实现模式</code>。因为在响应方法中，数据与行为的操作载体都以参数的形式出现。 </p>
</blockquote>
<h3 id="Struts1-X"><a href="#Struts1-X" class="headerlink" title="Struts1.X"></a>Struts1.X</h3><p>对于Struts1.X，我们还是把关注的重点放在Struts中的Controller层的定义上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response);</div></pre></td></tr></table></figure></p>
<p>如果和之前的Servlet模型加以比较我们就可以发现，Struts1.X对于基本的Servlet模型做了一定的扩展和重构：<br>1.保留了HttpServletRequest和HttpServletResponse这两大接口作为参数<br>2.将返回值改为ActionForward，并由Struts1.X框架通过处理ActionForward完成对响应结果的处理<br>3.增加了ActionMapping和ActionForm两大参数，前者表示Http请求的一个简要概括，后者表示一个数据模型，用以承载整个请求生命周期中的数据</p>
<p>经过一番扩展和重构，我们可以发现Struts1.X相比较于原始的Servlet模型已经有了一定的进步。比如，我们可以不再直接操作HttpServletResponse这样的原生Servlet对象来进行Http返回的处理；再比如，对于一些简单的请求数据读取，我们可以不必直接操作生硬的HttpServletRequest接口，而通过ActionForm来完成。 </p>
<blockquote>
<p>MVC模型发展到了这里，我们可以看到响应方法中的“返回值”已经能够被调动起来用在整个Http请求的处理过程中。因此，这种在响应方法中参数和返回值同时参与到Http请求的处理过程中的表现形态，被笔者冠以另外一个名称：<code>参数-返回值（Param-Return）实现模式</code>。 </p>
</blockquote>
<p>由于Struts1.X已经不再是一个底层的实现规范，于是响应方法“返回值”被框架引入，加入到了整个处理过程之中。我们可以看到，在这里最大的进步之处就在于：引入了新的编程元素，从而优化整个逻辑处理过程。编程元素的引入非常重要，因为对于一个任何一个程序员而言，充分调用所有可以利用的编程要素是衡量一个程序写得好坏的重要标准。之后，我们还可以看到其他的框架在引入编程元素这个方面所做的努力。 </p>
<h3 id="Webwork2-Struts2"><a href="#Webwork2-Struts2" class="headerlink" title="Webwork2 / Struts2"></a>Webwork2 / Struts2</h3><p>或许是看到了Struts1.X发展上的局限性，Apache社区与Opensymphony开源组织在2005年底宣布未来的Struts项目将与Webwork2项目合并，并联合推出Struts2，通过Apache社区的人气优势与OpenSymphony的技术优势，共同打造下一代的Web层开发框架。这也就是Struts2的由来。 </p>
<p>从整个过程中，我们可以发现，Webwork2和Struts2是一脉相承的Web层解决方案。而两者能够在一个相当长的时间段内占据开发市场主导地位的重要原因在于其技术上的领先优势。而这一技术上的领先优势，突出表现为对Controller的彻底改造：<br>1.在Controller中彻底杜绝引入HttpServletRequest或者HttpServletResponse这样的原生Servlet对象。<br>2.将请求参数和响应数据都从响应方法中剥离到了Controller中的属性变量</p>
<p>这两大改造被看作是框架的神来之笔。因为通过这一改造，整个Controller类彻底与Web容器解耦，可以方便地进行单元测试。而摆脱了Servlet束缚的Controller，也为整个编程模型赋予了全新的定义。 </p>
<p>当然，这种改造的前提条件在于Webwork2 / Struts2引入了另外一个重要的编程概念：ThreadLocal模式。使得Controller成为一个线程安全的对象被Servlet模型所调用，这也就突破了传统Servlet体系下，Servlet对象并非一个线程安全的对象的限制条件。 </p>
<p>从引入新的编程元素的角度来说，Webwork2 / Struts2无疑也是成功的。因为在传统Servlet模式中的禁地Controller中的属性变量被合理利用了起来作为请求处理过程中的数据部分。这样的改造不仅使得表达式引擎能够得到最大限度的发挥，同时使得整个Controller看起来更像是一个POJO。因而，这种表现形态被笔者冠以的名称是：<code>POJO实现模式</code>。 </p>
<p>POJO实现模式是一种具有革命性意义的模式，因为它能够把解耦合这样一个观点发挥到极致。从面向对象的角度来看，POJO模式无疑也是所有程序员所追求的一个目标。这也就是Webwork2 / Struts2那么多年来经久不衰的一个重要原因。 </p>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>相比较Webwork2 / Struts2，SpringMVC走了一条比较温和的改良路线。因为SpringMVC自始至终都没有突破传统Servlet编程模型的限制，而是在这过程中不断改良，不断重构，反而在发展中开拓了一条崭新的道路。<br>Controller改造中所涉及到的一些要点：<br><code>1. 使用参数-返回值（Param-Return）实现模式来打造Controller</code><br>方法的参数（email和password）被视作是Http请求参数的概括。而在这里，它们已经被SpringMVC的框架有效处理并屏蔽了内在的处理细节，呈现出来的是与请求参数名称一一对应的参数列表。而返回值ModelAndView则表示Http的响应是一个数据与视图的结合体，表示Http的处理结果。<br><code>2. 引入Annotation来完成请求-响应的映射关系</code><br>引入Annotation来完成请求-响应的映射关系，是SpringMVC的一个重大改造。在早期的SpringMVC以及其他的MVC框架中，通常都是使用XML作为基础配置的。而Annotation的引入将原本分散的关注点合并到了一起，为实现配置简化打下了坚实的基础。<br><code>3. 泛化参数和返回值的含义</code><br>这是一个蕴含的特点。事实上，SpringMVC在响应方法上，可以支持多种多样不同的参数类型和返回值类型。例如，当参数类型为Model时，SpringMVC将会自动将请求参数封装于Model内部而传入请求方法；当返回值类型是String时，直接表示SpringMVC需要返回的视图类型和视图内容。当然，这些泛化的参数和返回值的内容全部都由SpringMVC在框架内部处理了。 </p>
<h2 id="MVC模型的发展轨迹"><a href="#MVC模型的发展轨迹" class="headerlink" title="MVC模型的发展轨迹"></a>MVC模型的发展轨迹</h2><p>之前讲了那么多MVC模型的实现形态，我们是否能从中总结出一条发展轨迹呢？答案是肯定的，笔者在这里作了一副图：<br><img src="https://haymaicc.github.io/res/controller.png" alt=""><br>从图中，我们可以看到三类完全不同的发展方向。目前，<code>Struts1.X这一条路被证明已经穷途末路；另外的两条发展轨迹总体来说实力相当，SpringMVC大有赶超之势</code>。 </p>
]]></content>
      
        <categories>
            
            <category> SpringMvc </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringMvc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis 学习]]></title>
      <url>/2017/05/30/mybatis/</url>
      <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><strong>介绍mybatis</strong><br><strong>mybatis入门</strong><br><strong>从配置文件入手了解怎么使用mybatis</strong><br><strong>mapper 接口没有实现类，是怎么执行数据库操作的，原理是什么</strong><br><strong>sqlsession 内部实现的原理</strong><br><strong>阅读源码的主要几个重要类</strong></p>
<a id="more"></a>
<h2 id="mybatis是啥"><a href="#mybatis是啥" class="headerlink" title="mybatis是啥"></a>mybatis是啥</h2><blockquote>
<p>MyBatis 世界上流行最广泛的SQL 映射框架，由 Clinton Begin 在 2002年创建，其后，捐献给了Apache 基金会，成立了iBatis 项目。<br>2010年 5月，将代码库迁致 Google Code，并更名为MyBatis。<br>关于以前的版本，请访问   <a href="http://ibatis.apache.org" target="_blank" rel="external"></a><br>关于更名后最新的版本，请访问：<a href="http://code.google.com/p/mybatis" target="_blank" rel="external"></a></p>
</blockquote>
<p>MyBatis 是一个可以自定义 SQL、存储过程和高级映射的持久层框架。MyBatis 摒除了大部分的 JDBC 代码、手工设置参数和结果集重获。<br>MyBatis 只使用简单的 XML 和注解来配置和映射基本数据类型、 Map 接口和 POJO 到数据库记录</p>
<h2 id="mybatis入门"><a href="#mybatis入门" class="headerlink" title="mybatis入门"></a>mybatis入门</h2><p><a href="http://www.mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="external">官方文档</a></p>
<h3 id="使用简介"><a href="#使用简介" class="headerlink" title="使用简介"></a>使用简介</h3><p>每一个 MyBatis 应该都是以一个 <code>SqlSessionFactory</code>实例为中心。<br>一个SqlSessionFactory实例可以使用 <code>SqlSessionFactoryBuilder</code> 来创造。从配置类中创造的定制 SqlSessionFactoryBuilder 实例，<br>可以使用XML 配置文件来生成一个SqlSessionFactory实例<br>SqlSessionFactoryBuilder通过Java io流读取配置文件构建 SqlSessionFactory对象<br><code>Resources</code>A class to simplify access to resources through the classloader.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String resource = &quot;org/mybatis/example/Configuration.xml&quot;;</div><div class="line">Reader reader = Resources.getResourceAsReader(resource);</div><div class="line">SqlSessionFactory sqlSessionFactory= new SqlSessionFactoryBuilder().build(reader);</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE configuration</span></div><div class="line">  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</div><div class="line">  "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</div><div class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/example/BlogMapper.xml"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="SqlSessionFactory："><a href="#SqlSessionFactory：" class="headerlink" title="SqlSessionFactory："></a>SqlSessionFactory：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlSessionFactory</span> </span>&#123;</div><div class="line">    <span class="function">SqlSession <span class="title">openSession</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">SqlSession <span class="title">openSession</span><span class="params">(<span class="keyword">boolean</span> var1)</span></span>;</div><div class="line">    <span class="function">SqlSession <span class="title">openSession</span><span class="params">(Connection var1)</span></span>;</div><div class="line">    <span class="function">SqlSession <span class="title">openSession</span><span class="params">(TransactionIsolationLevel var1)</span></span>;</div><div class="line">    <span class="function">SqlSession <span class="title">openSession</span><span class="params">(ExecutorType var1)</span></span>;</div><div class="line">    <span class="function">SqlSession <span class="title">openSession</span><span class="params">(ExecutorType var1, <span class="keyword">boolean</span> var2)</span></span>;</div><div class="line">    <span class="function">SqlSession <span class="title">openSession</span><span class="params">(ExecutorType var1, TransactionIsolationLevel var2)</span></span>;</div><div class="line">    <span class="function">SqlSession <span class="title">openSession</span><span class="params">(ExecutorType var1, Connection var2)</span></span>;</div><div class="line">    <span class="function">Configuration <span class="title">getConfiguration</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><blockquote>
<p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳范围是方法范围<br>（也就是局部方法变量）。你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在以保证所有的<br> XML 解析资源开放给更重要的事情。</p>
</blockquote>
<h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><blockquote>
<p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 SqlSessionFactory<br>的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏味道（bad smell）”。因此 SqlSessionFactory<br>的最佳范围是应用范围。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p>
</blockquote>
<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><blockquote>
<p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的范围是请求或方法范围。<br>绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将 SqlSession 实例的引用放在任何类型的管理范围中，<br>比如 Serlvet 架构中的 HttpSession。如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的范围中。换句话说，<br>每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的,<br>你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。</p>
</blockquote>
<p>下面的示例就是一个确保 SqlSession 关闭的标准模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SqlSession session = sqlSessionFactory.openSession();</div><div class="line">    try &#123;</div><div class="line">        // do work</div><div class="line">    &#125; </div><div class="line">    finally &#123;</div><div class="line">        session.close();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在你的所有的代码中一致性地使用这种模式来保证所有数据库资源都能被正确地关闭。</p>
<h2 id="从配置文件入手了解怎么使用mybatis"><a href="#从配置文件入手了解怎么使用mybatis" class="headerlink" title="从配置文件入手了解怎么使用mybatis"></a>从配置文件入手了解怎么使用mybatis</h2><blockquote>
<p>主要分为 xml 配置文件和xml 映射文件，<a href="http://www.mybatis.org/mybatis-3/zh/configuration.html" target="_blank" rel="external">官方文档</a>写的很详细不做赘述。</p>
</blockquote>
<h2 id="mapper-接口没有实现类，是怎么执行数据库操作的，原理是什么？？"><a href="#mapper-接口没有实现类，是怎么执行数据库操作的，原理是什么？？" class="headerlink" title="mapper 接口没有实现类，是怎么执行数据库操作的，原理是什么？？"></a>mapper 接口没有实现类，是怎么执行数据库操作的，原理是什么？？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SqlSession session = sqlSessionFactory.openSession();</div><div class="line">try &#123;</div><div class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</div><div class="line">  mapper.insert(Blog blog); </div><div class="line">&#125; finally &#123;</div><div class="line">  session.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="mybatis-mapper-执行原理图-画的不好不要怪我，捂脸-jpg-："><a href="#mybatis-mapper-执行原理图-画的不好不要怪我，捂脸-jpg-：" class="headerlink" title="mybatis  mapper 执行原理图(画的不好不要怪我，捂脸.jpg)："></a>mybatis  mapper 执行原理图(画的不好不要怪我，捂脸.jpg)：</h3><p><img src="https://haymaicc.github.io/res/mybatis_1.png" alt=""><br>详细怎么使用动态代理来实现可以参考 <a href="https://my.oschina.net/zudajun/blog/666223" target="_blank" rel="external">Mybatis3.3.x技术内幕（二）：动态代理之投鞭断流（自动映射器Mapper的底层实现原理）</a></p>
<h2 id="sqlseesion-的实现原理"><a href="#sqlseesion-的实现原理" class="headerlink" title="sqlseesion 的实现原理"></a>sqlseesion 的实现原理</h2><p>上面讲到了由mapper 接口执行方法，到sqlsession的api 的调用，下面简单的介绍一下sqlseesion 的实现原理：<br><img src="https://haymaicc.github.io/res/mybatis_2.jpg" alt=""></p>
<h3 id="sqlsession中有confirguration-配置文件信息"><a href="#sqlsession中有confirguration-配置文件信息" class="headerlink" title="sqlsession中有confirguration(配置文件信息)"></a>sqlsession中有confirguration(配置文件信息)</h3><blockquote>
<p>配置文件的读取XML 的解析封装占了mybatis 源码的很多篇幅。简单来说就是mybatis 从xml中取得的信息全部封装在Confirguration类中，很多类都冗余了confirguration 字段。</p>
</blockquote>
<h3 id="根据configuration-调用executor"><a href="#根据configuration-调用executor" class="headerlink" title="根据configuration 调用executor"></a>根据configuration 调用executor</h3><blockquote>
<p>在xml 里有个defaultExecutorType是配置Excutor 的类别的</p>
</blockquote>
<p><img src="https://haymaicc.github.io/res/mybatis_3.png" alt=""></p>
<h3 id="executor-有五种"><a href="#executor-有五种" class="headerlink" title="executor(有五种)"></a>executor(有五种)</h3><p><code>SimpleExecutor</code>：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。（可以是Statement或PrepareStatement对象）<br><code>ReuseExecutor</code>：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map<string, statement="">内，供下一次使用。（可以是Statement或PrepareStatement对象）<br><code>BatchExecutor</code>：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理的；BatchExecutor相当于维护了多个桶，每个桶里都装了很多属于自己的SQL，就像苹果蓝里装了很多苹果，番茄蓝里装了很多番茄，最后，再统一倒进仓库。（可以是Statement或PrepareStatement对象）<br><code>CachingExecutor</code>：装饰设计模式典范，先从缓存中获取查询结果，存在就返回，不存在，再委托给Executor delegate去数据库取，delegate可以是上面任一的SimpleExecutor、ReuseExecutor、BatchExecutor。<br><code>ClosedExecutor</code>：毫无用处，读者可自行查看其源码，仅作为一种标识，和Serializable标记接口作用相当。</string,></p>
<h3 id="Excutor内部调用statementhadler-对jdbc-的stement操作的封装"><a href="#Excutor内部调用statementhadler-对jdbc-的stement操作的封装" class="headerlink" title="Excutor内部调用statementhadler (对jdbc 的stement操作的封装)"></a>Excutor内部调用statementhadler (对jdbc 的stement操作的封装)</h3><h3 id="并且用resultSethandler-封装返回结果。"><a href="#并且用resultSethandler-封装返回结果。" class="headerlink" title="并且用resultSethandler 封装返回结果。"></a>并且用resultSethandler 封装返回结果。</h3><h2 id="阅读源码的主要几个重要类"><a href="#阅读源码的主要几个重要类" class="headerlink" title="阅读源码的主要几个重要类"></a>阅读源码的主要几个重要类</h2><ul>
<li>SqlSession            作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能</li>
<li>Executor              MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护</li>
<li>StatementHandler   封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合。</li>
<li>ParameterHandler   负责对用户传递的参数转换成JDBC Statement 所需要的参数，</li>
<li>ResultSetHandler    负责将JDBC返回的ResultSet结果集对象转换成List类型的集合；</li>
<li>TypeHandler          负责java数据类型和jdbc数据类型之间的映射和转换</li>
<li>MappedStatement   MappedStatement维护了一条<select|update|delete|insert>节点的封装， </select|update|delete|insert></li>
<li>SqlSource            负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回</li>
<li>BoundSql             表示动态生成的SQL语句以及相应的参数信息</li>
<li>Configuration        MyBatis所有的配置信息都维持在Configuration对象之中。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> mybatis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[zookeeper 学习]]></title>
      <url>/2017/05/17/zk/</url>
      <content type="html"><![CDATA[<p><img src="https://haymaicc.github.io/res/zk.png" alt=""></p>
<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ol>
<li>分布式通知，协调</li>
<li>集群管理</li>
<li>Master 选举</li>
<li>分布式锁 分布式队列</li>
</ol>
<a id="more"></a>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><blockquote>
<p>类似于文件系统结构，每一个节点称为ZNode   可以存放数据</p>
</blockquote>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ol>
<li>2n+1 个server   当n+1个节点可用时，系统可用</li>
<li>server 角色类型 存放数据  ( leader： 不接受客户端请求负责投票和决议，最终更新状态     </li>
<li>follwer：接受客户端请求并返回，参与leader 发起的投票</li>
</ol>
<h2 id="leader-选举"><a href="#leader-选举" class="headerlink" title="leader 选举"></a>leader 选举</h2><blockquote>
<p>leader 失去Leader 地位时使用paxos 算法选举</p>
</blockquote>
<ol>
<li>每一个server向所有server 请求成为leader</li>
<li>投票超过一半的成为leader ,否则重新执行第一步</li>
</ol>
<h2 id="数据交互"><a href="#数据交互" class="headerlink" title="数据交互"></a>数据交互</h2><ul>
<li>读：直接 读取client连接的server 的数据</li>
<li>更新  1、 client向server发送请求 2、server向leader发送请求 3、leader发起proposol过程 4、follower反馈结果 5、leader接收响应，如果超过⼀半认为成功，则认为 成功，否则认为失败。并将结果反馈给server 6、server将结果反馈给client</li>
</ul>
<h2 id="ObServer节点"><a href="#ObServer节点" class="headerlink" title="ObServer节点"></a>ObServer节点</h2><p>ObServer节点：和client交互，存有数据的副本，不参与投票</p>
<h2 id="client架构"><a href="#client架构" class="headerlink" title="client架构"></a>client架构</h2><ol>
<li>ClientCnxn：管理  client和ZooKeeper间  的网络连接</li>
<li>WatcherManager：管 理Watcher，如：负 责对ZNode的监控</li>
<li>Zookeeper：Client交 互的主要接⼝，如创 建Znode、更新ZNode</li>
</ol>
<h2 id="ZooKeeper承诺"><a href="#ZooKeeper承诺" class="headerlink" title="ZooKeeper承诺"></a>ZooKeeper承诺</h2><p>顺序性  原⼦性 强⼀致性 可靠性 实时性</p>
]]></content>
      
        <categories>
            
            <category> 分布式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[大话数据结构学习笔记（三）]]></title>
      <url>/2017/05/16/data-structure3/</url>
      <content type="html"><![CDATA[<p><a href="https://haymaicc.github.io/2017/05/06/data_structure1/">笔记（一）的传送门</a><br><a href="https://haymaicc.github.io/2017/05/07/data-structure2/">笔记（二）的传送门</a></p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><blockquote>
<p>查找就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素</p>
</blockquote>
<h2 id="顺序查找-O-n"><a href="#顺序查找-O-n" class="headerlink" title="顺序查找 O(n)"></a>顺序查找 O(n)</h2><blockquote>
<p>从表中第一个记录开始，逐个与给定值进行比较，若某个记录的关键字和给定值相等，则查找成功；反之，若直到最后一个记录，其关键字和给定值都不相等，则表明表中没有所查记录，查找失败。</p>
</blockquote>
<a id="more"></a>
<h3 id="二分-折半查找（有序表）-O-logn"><a href="#二分-折半查找（有序表）-O-logn" class="headerlink" title="二分/折半查找（有序表） O(logn)"></a>二分/折半查找（有序表） O(logn)</h3><blockquote>
<p>先确定待查记录所在的范围，然后逐步缩小范围，直到找到或者找不到记录为止。</p>
</blockquote>
<h3 id="插值查找-O-logn"><a href="#插值查找-O-logn" class="headerlink" title="插值查找  O(logn)"></a>插值查找  O(logn)</h3><blockquote>
<p>插值查找和折半查找类似，可以通过比较表中的某项记录，确定查找记录的范围。唯一不同的是，对每次查找的中间点进行了变换，使之更加接近待查找的记录，减少了查找的次数。折半查找的中间点mid = low + (high – low) / 2，插值查找对1/2进行了修正，mid = low + (key – a[low])/(a[high] – a[low]) * (high – low)</p>
</blockquote>
<h3 id="斐波那契查找-O-logn"><a href="#斐波那契查找-O-logn" class="headerlink" title="斐波那契查找 O(logn)"></a>斐波那契查找 O(logn)</h3><blockquote>
<p>依然是对查找点的优化，采用Fibonacci数组，找到对于当前长度的有序表的黄金分割点，作为每次的中间值。</p>
</blockquote>
<p>对于平均性能，斐波那契查找要优于折半查找，但如果是最坏情况，查找效率低于折半查找。有序表查找是一种针对查找优化的表结构，查找的时间复杂度是O(logn)。但有序表的插入和删除性能是比较差的，插入和删除不能破坏有序表的特性。</p>
<h2 id="线形索引查找"><a href="#线形索引查找" class="headerlink" title="线形索引查找"></a>线形索引查找</h2><blockquote>
<p>索引是关键词和记录关联的过程，按照结构可以分为线形索引，树形索引和多级索引。线形索引就是将索引项集合组织为线形结构，也称索引表。</p>
</blockquote>
<h3 id="稠密索引-O-logn"><a href="#稠密索引-O-logn" class="headerlink" title="稠密索引 O(logn)"></a>稠密索引 O(logn)</h3><blockquote>
<p>稠密索引是关键码有序的，因此可以对索引使用折半、插值、斐波那契等有序表查找算法，大大提高了效率。</p>
</blockquote>
<p>优缺点：和有序表类似的是，稠密索引必须要维护索引的有序性。另外如果数据量很大，也要同时维护一个同样规模的索引，可能就需要反复访问磁盘，降低了查找性能。</p>
<h3 id="分块索引-介于O-n-和O-logn-之间"><a href="#分块索引-介于O-n-和O-logn-之间" class="headerlink" title="分块索引  介于O(n)和O(logn)之间"></a>分块索引  介于O(n)和O(logn)之间</h3><blockquote>
<p>如果对索引进行一次分级呢？对于一级索引下，可能会有多个记录，称之为一个块，块内的记录再获得一个二级的索引。这些块有一个条件，就是块内无序，块间有序。块内无序就是在一级索引内部的记录可以是无序的，只要落在索引的范围内就可以；块间有序就是下一个块所有的关键字都要大于上一个块的最大关键字。因此对于一个块结构来讲，它具有最大关键码，块中的记录个数和指向块首数据的指针</p>
</blockquote>
<p>分块索引兼顾了有序和无序的需求，平衡了插入，删除和查找的性能，普遍用于数据库查找技术等</p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><blockquote>
<p>倒排索引主要应用于搜索引擎。基本思想就是将得到的key-value关系进行一个反映射，得到某个value有多少个key指向它。比如查找某个单词出现在哪些文章中，可以先访问文章中的所有单词，建立一个单词的索引，将出现该单词的文章记录到索引中。这样在搜索时直接输入单词，就能得到文章列表。</p>
</blockquote>
<p>优缺点：倒排索引的优点是速度快，缺点就是记录不等长，维护比较困难，插入和删除都要做相应的处理。比如删除某个文章，就可能要对所有的单词都进行考察。</p>
<h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><blockquote>
<p>有序表的问题就是如果插入一个较小的记录，就要把比它大的记录依次移动，腾出插入的位置。如果用二叉树来实现呢，只需要让这个较小的记录成为某个结点的左孩子就可以了。为什么是左孩子呢，和二叉排序数的定义有关，简单来说，二叉排序树的中序遍历就是一个有序表。这样插入任何一个记录都不需要改变已经建好的树</p>
</blockquote>
<h3 id="查找："><a href="#查找：" class="headerlink" title="查找："></a>查找：</h3><blockquote>
<p>查找某个记录时，从根结点开始，如果查找记录大于该结点的值，就走右子树；如果小于该结点的值，就走左子树。不断向下查找，直到找到该记录，或者到叶子结点的值和查找记录不同，未找到该记录。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入和查找类似，向下找到最接近它的结点，然后把该记录作为它的左孩子或者右孩子。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除相对查找和插入来讲复杂一点，主要复杂在如果处理它的子树。删除分为几种情况，如果删除结点是叶子结点，直接把它和二叉排序树断开即可，不影响树上的其他结点。如果删除结点带左子树或者右子树（不同时），那就将它左子树或者右子树的根结点代替它，连接到树上。如果删除结点同时带有左子树和右子树呢？想要对原排序树的破坏最小，最好的办法是找到该结点的前驱或者后继结点，这可以很容易的找到。假设我们这里使用删除结点的前驱结点，要先将前驱结点的值赋给删除结点，如果前驱结点就是删除结点的左孩子（删除结点及其子孙只有左孩子，斜树），就将前驱结点的左子树接到删除结点的左子树上；如果前驱结点是某个结点的右孩子（删除结点及其子孙不只有左孩子），还要将它的左子树接到它父母的右子树上。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>如果二叉排序树是平衡的，那么查找的时间复杂度是O(logn)；如果是不平衡，比如最极端的斜树，那么时间复杂度是O(n)。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>二叉排序树保留了有序表查找高效的特点，最理想的情况能达到O(logn)的时间复杂度，并且解决了插入和删除记录的问题，能够保证树的整体结构不受影响。缺点就是可能在插入的过程中，二叉排序树不能保持平衡，出现了某一边的树远远大于另一边，降低了查找的效率。后面提到的平衡二叉树解决了这个问题。</p>
</blockquote>
<h2 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h2><blockquote>
<p>平衡二叉树的出现是为了解决二叉排序树可能出现的不平衡问题。平衡二叉树的概念是树中任何结点的平衡因子只能是-1,0,1，也就左子树和右子树的深度相差最多是1。为了实现这个目的，每次插入记录后，都会检查二叉树是否处在平衡状态，如果不是的话，会进行相应的旋转操作使之平衡。平衡的过程就是从新插入的结点向上查找，如果某个结点的BF=2，就顺时针旋转。最简单的旋转就是对于斜树，直接将BF=2结点的孩子作为新的子树根结点，将BF=2连接到它的右孩子。稍复杂的旋转就是BF=2和它的左孩子有相同的旋转方向，这样将它的左孩子作为新的子数根结点，BF=2连接在新根结点的右子树上，再将新的根结点原来的右孩子连接到BF=2的左子树上。最复杂的旋转就是BF=2和它的左孩子是相反的旋转方向，就要将它的左孩子先进行一次右旋转，再对BF=2作左旋转。同样，如果找到某个结点的BF=-2，做逆时针旋转，旋转的方法和顺时针旋转类似。</p>
</blockquote>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><blockquote>
<p>由于平衡二叉树的特性，它的时间复杂度一直是O(logn)。</p>
</blockquote>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><blockquote>
<p>平衡二叉树的优点就在于将不平衡消灭在最初的阶段，保持了很好的查找特性。缺点？比较复杂？</p>
</blockquote>
<h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><blockquote>
<p>其中的每一个节点都具有两个孩子（称为2节点）或者三个孩子（称为3节点）。并且2-3树中所有的叶子都在同一层上。<br> 一个2节点包含一个元素和两个孩子（或者没有孩子）。<br> 一个3节点包含一小一大两个元素和三个孩子（或者没有孩子）<br><img src="https://haymaicc.github.io/res/structure_1.jpg" alt=""></p>
</blockquote>
<h3 id="2-3树的插入实现"><a href="#2-3树的插入实现" class="headerlink" title="2-3树的插入实现"></a>2-3树的插入实现</h3><p>(1)对于空树，插入一个2节点即可；<br>(2)插入节点到一个2节点的叶子上。由于本身就只有一个元素，所以只需要将其升级为3节点即可。<br><img src="https://haymaicc.github.io/res/structure_2.jpg" alt=""><br>(3)插入节点到一个3节点的叶子上。因为3节点本身最大容量，因此需要拆分，且将树中两元素或者插入元素的三者中选择其一向上移动一层。<br><img src="https://haymaicc.github.io/res/structure_3.jpg" alt=""></p>
<h3 id="2-3树的删除实现"><a href="#2-3树的删除实现" class="headerlink" title="2-3树的删除实现"></a>2-3树的删除实现</h3><p>(1)所删元素位于一个3节点的叶子节点上，直接删除，不会影响树结构。<br>(2)所删元素位于一个2节点上，直接删除，破坏树结构<br>分为四种情况<br><img src="https://haymaicc.github.io/res/structure_4.jpg" alt=""><br>3）所删元素位于非叶子的分支节点。此时按树中序遍历得到此元素的前驱或后续元素，补位。<br><img src="https://haymaicc.github.io/res/structure_5.jpg" alt=""></p>
<h2 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h2><blockquote>
<p>2-3-4树是2-3树的扩展，包括了4节点的使用，一个4节点包含小中大三个元素和四个孩子（或没有孩子）。</p>
</blockquote>
<h3 id="2-3-4树插入实现"><a href="#2-3-4树插入实现" class="headerlink" title="2-3-4树插入实现"></a>2-3-4树插入实现</h3><p>构建一个数组为{7,1,2,5,6,9,8,4,3}的2-3-4树的过程<br><img src="https://haymaicc.github.io/res/structure_6.jpg" alt=""></p>
<h3 id="2-3-4树删除实现"><a href="#2-3-4树删除实现" class="headerlink" title="2-3-4树删除实现"></a>2-3-4树删除实现</h3><p>删除顺序使1,6,3,4,5,2,9<br><img src="https://haymaicc.github.io/res/structure_7.jpg" alt=""></p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><blockquote>
<p>B树（B-树）是一种平衡的多路查找树。2-3树和2-3-4树都是B树的特例。节点最大的孩子数组称为B树的阶（order），因此，2-3树是3阶B树，2-3-4树是4阶B树。<br><img src="https://haymaicc.github.io/res/structure_8.jpg" alt=""></p>
<p>B树的插入和删除和2-3树、2-3-4树类似。</p>
</blockquote>
<p>B树的数据结构为内外存的数据交互准备的。当要处理的数据很大时，无法一次全部装入内存。这时对B树调整，使得B树的阶数与硬盘存储的页面大小相匹配。<br>比如说一棵B树的阶为1001（即1个节点包含1000个关键字），高度为2（从0开始），它可以存储超过10亿个关键字（1001x1001x1000+1001x1000+1000）,<br>只要让根节点持久的保留在内存中，那么在这颗树上，寻找某一个关键字至多需要两次硬盘的读取即可。</p>
<p>对于n个关键字的m阶B树，最坏情况查找次数计算<br>第一层至少1个节点，第二层至少2个节点，由于除根节点外每个分支节点至少有⌈m/2⌉棵子树，则第三层至少有2x⌈m/2⌉个节点。。。这样第k+1层至少有2x(⌈m/2⌉)^(k-1),实际上，k+1层的节点就是叶子节点。若m阶B树有n个关键字，那么当你找到叶子节点，其实也就等于查找不成功的节点为n+1，因此<br>n+1&gt;=2x(⌈m/2⌉)^(k-1),即<br>k&lt;=log<a href="(n+1">m/2</a>/2+1)<br>在含有n个关键字的B树上查找时，从根节点到关键字节点的路径上涉及的节点数不超多 log<a href="(n+1">m/2</a>/2+1)</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>下图B树，我们要遍历它，假设每个节点都属于硬盘的不同页面，我们为了中序遍历所有的元素，页面2-页面1-页面3-页面1-页面4-页面1-页面5.<br>而且我们每经过节点遍历时，都会对节点中的元素进行一次遍历，糟糕！有没有可能让遍历时每个元素只访问一次呢？<br><img src="https://haymaicc.github.io/res/structure_9.jpg" alt=""><br>下图就是B+树，灰色关键字，在根节点出现，在叶子节点中再次列出。<br><img src="https://haymaicc.github.io/res/structure_10.jpg" alt=""></p>
<blockquote>
<p>B+树适合随机查找，只不过查到后是索引，不能提供实际记录的访问，还需要到达包含此关键字的终端节点。非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。B+树适合带有范围的查找。B+树插入、删除类似B树。<br><a href="http://blog.csdn.net/acs713/article/details/6880375" target="_blank" rel="external">详细了解B树和B+树</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[各种IO的区别]]></title>
      <url>/2017/05/07/IO/</url>
      <content type="html"><![CDATA[<h2 id="BIO（同步阻塞IO）"><a href="#BIO（同步阻塞IO）" class="headerlink" title="BIO（同步阻塞IO）"></a>BIO（同步阻塞IO）</h2><p>使用ServerSocket绑定IP地址和监听端口，客户端发起连接，通过三次握手建立连接，用socket来进行通信，通过输入输出流的方式来进行同步阻塞的通信<br>每次客户端发起连接请求，都会启动一个线程<br>线程数量：客户端并发访问数为1：1，由于线程是JAVA虚拟机中非常宝贵的资源，一旦线程数急剧增加，系统性能会急剧下降，导致线程栈溢出，创建新的线程失败，并最终导致宕机<br>所以在JDK1.4之前，人们想到了一种方法，即PIO方式</p>
<a id="more"></a>
<h2 id="PIO（伪异步阻塞IO）"><a href="#PIO（伪异步阻塞IO）" class="headerlink" title="PIO（伪异步阻塞IO）"></a>PIO（伪异步阻塞IO）</h2><p>使用线程池来处理客户端的请求<br>客户端个数：线程池最大线程数=M：N，其中M远大于N<br>在read和write的时候，还是IO阻塞的，只是把每个线程交由线程池来控制管理</p>
<h2 id="NIO（异步阻塞IO）"><a href="#NIO（异步阻塞IO）" class="headerlink" title="NIO（异步阻塞IO）"></a>NIO（异步阻塞IO）</h2><p>用NIO方式处理IO<br>使用多路复用器Selector来轮询每个通道Channel，当通道中有事件时就通知处理，不会阻塞<br>使用相当复杂</p>
<h2 id="AIO（真正的异步非阻塞IO）"><a href="#AIO（真正的异步非阻塞IO）" class="headerlink" title="AIO（真正的异步非阻塞IO）"></a>AIO（真正的异步非阻塞IO）</h2><p>NIO2.0引入了新的异步通道的概念，不需要使用多路复用器（Selector）对注册通道进行轮询即可实现异步读写，从而简化了NIO编程模型</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[大话数据结构学习笔记（二）]]></title>
      <url>/2017/05/07/data-structure2/</url>
      <content type="html"><![CDATA[<p><a href="https://haymaicc.github.io/2017/05/06/data_structure1/">笔记（一）的传送门</a></p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><blockquote>
<p>是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为G(V,E)，其中G表示一个图，V是图G中的顶点，E是图G中边的集合</p>
</blockquote>
<a id="more"></a>
<h3 id="关于图的一些术语解释"><a href="#关于图的一些术语解释" class="headerlink" title="关于图的一些术语解释"></a>关于图的一些术语解释</h3><p><code>顶点（Vertex）</code>：<br>图中的结点又称为顶点。 </p>
<p><code>无边图</code>：<br>若顶点Vi到Vj之间的边没有方向，则称这条边为无项边（Edge），用序偶对(Vi,Vj)标示。<br>对于下图无向图G1来说，G1=(V1, {E1})，其中顶点集合V1={A,B,C,D}；边集合E1={(A,B),(B,C),(C,D),(D,A),(A,C)}:<br><img src="http://images.cnitblog.com/blog/380281/201307/13102520-912a10a40eb347b1a550f60a4feaae02.png" alt=""></p>
<p><code>有向图</code>：<br>若从顶点Vi到Vj的边是有方向的，则成这条边为有向边，也称为弧（Arc）。用有序对（Vi，Vj）标示，Vi称为弧尾，Vj称为弧头。如果任意两条边之间都是有向的，则称该图为有向图。<br>有向图G2中，G2=（V2,{E2}），顶点集合（A,B,C,D）,弧集合E2={<a,d>,{B,A},<c,a>,<b,c>}.</b,c></c,a></a,d></p>
<p><code>有向和无向完全图</code><br><img src="http://img.blog.csdn.net/20131113203819437" alt=""></p>
<p><code>权（Weight）</code>：<br>有些图的边和弧有相关的数，这个数叫做权（Weight）。这些带权的图通常称为网（Network）</p>
<p><code>度（Degree）</code>：<br>无向图中顶点v的度是关联于该顶点的边的数目，记为TD(v)。<br>入度（Indegree）：若G为有向图，则把以顶点v为终点的边的数目，称为v的入度，记为ID(v)。<br>出度（Outdegree）：若G为有向图，则把以顶点v为始点的边的数目，称为v的出度，记为OD(v)。<br>如图①：A的度为3。<br>如图②：A的入度为2，出度为1，所以A的度为3。<br><img src="http://img.blog.csdn.net/20131113205232156" alt=""></p>
<p><code>子图（Subgraph</code>：<br>设G=(V,E)是一个图，若E’是E的子集，V’是V的子集，使得E’中的边仅与V’中顶点相关联，则图G’=(V’,E’)称为图G的子图。<br>如图：②为①的4个子图<br><img src="http://img.blog.csdn.net/20131112231539062" alt=""></p>
<p><code>路径（Path</code><br>无向图G=(V,E)中从顶点v到顶点v’的路径是一个顶点序列(v=vi0,vi1,…,vin=v’)，其中(vij-1,vij)∈E，1≤j≤n。有向图G=(V,E)中从顶点v到顶点v’的路径是一个顶点序列(v=vi0,vi1,…,vin=v’)，其中〈vij-1,vij〉∈E，1≤j≤n。<br>　简单路径：序列中顶点不重复出现的路径。<br>　环（Cycle）：又称回路，第一个顶点和最后一个顶点相同的路径。<br>　简单回路：又称简单环，除了第一个顶点和最后一个顶点外，其余顶点不重复的回路。</p>
<p><code>连通</code>：<br>在无向图G中，如果从顶点v到顶点v’有路径，则称v和v’是连通的。<br>    连通图（Connected Graph）：如果对于图中的任意两个顶点vi、vj∈V，vi和vj都是连通的，则称该图为连通图。<br>    连通分量（Connected Component）：无向图中的极大连通子图。<br>    强连通图：在有向图G中，如果对于每一对vi，vj∈V，vi≠vj，从vi到vj和从vj到vi都存在路径，则称G是强连通图。<br>    强连通分量：有向图中的极大连通子图<br><img src="http://img.blog.csdn.net/20131113205509265" alt=""></p>
<p><code>生成树（Spanning Tree）</code>：<br>含有连通图的全部顶点的一个极小连通子图。</p>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><p><code>邻接矩阵</code>：<br>图的邻接矩阵存储方式是用两个数组来标示图。一个一位数组存储图顶点的信息，一个二维数组（称为邻接矩阵）存储图中边或者弧的信息。</p>
<p>设图G有n个顶点，则邻接矩阵是一个n*n的方阵，定义为：<br><img src="http://images.cnitblog.com/blog/380281/201307/13102724-c49b3c87958e493696d55d3306597b5c.png" alt=""></p>
<p>实例如下，左图是一个无向图。右图是邻接矩阵表示：<br><img src="http://images.cnitblog.com/blog/380281/201307/13102739-ae381b43e0124cc7908c055f350dc03a.png" alt=""></p>
<p>无向网图的创建代码，时间复杂度为O{n + n2 + e}。</p>
<p><code>邻接表</code><br>用数组和链表结合的存储方式来标示图的方法称为邻接表。</p>
<blockquote>
<p>原理：（类似于树的孩子表示法的第三种存储方式）<br>图中顶点用一个一维数组存储，当然也可以用单链表存储。<br>图中每个顶点 Vi 的所有邻接点构成一个线性表，由于邻接点的个数不确定，所以我们选择用单链表来存储。无向图成为顶点vi的边表，有向图则称为顶点vi作为弧尾的出边表。</p>
</blockquote>
<p><img src="http://images.cnitblog.com/blog/380281/201307/13103212-bec29eec5fda4044a93ee18ee4c10607.png" alt=""></p>
<p><code>十字链表（OrthogonalList）</code><br>十字链表把邻接表与逆邻接表结合起来，解决了出度和入度的问题。</p>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><blockquote>
<p>从图中某个顶点出发访遍图中其余顶点，且使每个顶点仅被访问依次，这一过程叫做图的遍历.</p>
</blockquote>
<p>遍历方法： 深度优先遍历和广度优先遍历</p>
<p><code>深度优先遍历 O(n^2)</code>：从图中某个顶点出发v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先便利图，直到图中所有和v有相同路径的顶点都被访问。</p>
<p><code>广度优先遍历（Breadth_First_Search）O(n^2)</code> 又称为广度优先搜索，简称BFS</p>
<p>深度优先更适合目标比较明确，以找到目标为主要目的的情况。<br>广度优先更适合在不断扩大遍历范围时找到相对最优解的情况。</p>
<h3 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h3><p><code>最小生成树（普里姆算法 O(n^2)）</code></p>
<blockquote>
<p>我们把构造连通图的最小代价生成树称为最小生成树</p>
</blockquote>
<p>最小生成树实现算法：普利姆算法和克鲁斯卡尔算法</p>
<p><code>普利姆算法</code></p>
<blockquote>
<p>假设 N=(P, {E})是连通网， TE是N上最小生成树中边的集合。算法从 U={u0}（u0∈V），TE={}开始。重复执行下述操作：在所有 u∈U,v∈V-U的边（u,v）∈E中找一条代价最小的边（u0,v0）并入集合TE，同时v0并入U，直至U=V为止。此时TE中必有 n-1条边。则T=（V,{TE}）为最小生成树。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prim</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;Vertex&gt; vertexList = <span class="keyword">new</span> ArrayList&lt;Vertex&gt;();<span class="comment">//结点集</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;Edge&gt; EdgeQueue = <span class="keyword">new</span> ArrayList&lt;Edge&gt;();<span class="comment">//边集</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;Vertex&gt; newVertex = <span class="keyword">new</span> ArrayList&lt;Vertex&gt;();<span class="comment">//已经 访问过的结点</span></div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		primTree();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">()</span> </span>&#123;</div><div class="line">		Vertex v1 = <span class="keyword">new</span> Vertex(<span class="string">"a"</span>);</div><div class="line">		Prim.vertexList.add(v1);</div><div class="line">		Vertex v2 = <span class="keyword">new</span> Vertex(<span class="string">"b"</span>);</div><div class="line">		Prim.vertexList.add(v2);</div><div class="line">		Vertex v3 = <span class="keyword">new</span> Vertex(<span class="string">"c"</span>);</div><div class="line">		Prim.vertexList.add(v3);</div><div class="line">		Vertex v4 = <span class="keyword">new</span> Vertex(<span class="string">"d"</span>);</div><div class="line">		Prim.vertexList.add(v4);</div><div class="line">		Vertex v5 = <span class="keyword">new</span> Vertex(<span class="string">"e"</span>);</div><div class="line">		Prim.vertexList.add(v5);</div><div class="line">		addEdge(v1, v2, <span class="number">6</span>);</div><div class="line">		addEdge(v1, v3, <span class="number">7</span>);</div><div class="line">		addEdge(v2, v3, <span class="number">8</span>);</div><div class="line">		addEdge(v2, v5, <span class="number">4</span>);</div><div class="line">		addEdge(v2, v4, <span class="number">5</span>);</div><div class="line">		addEdge(v3, v4, <span class="number">3</span>);</div><div class="line">		addEdge(v3, v5, <span class="number">9</span>);</div><div class="line">		addEdge(v5, v4, <span class="number">7</span>);</div><div class="line">		addEdge(v5, v1, <span class="number">2</span>);</div><div class="line">		addEdge(v4, v2, <span class="number">2</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Vertex a, Vertex b, <span class="keyword">int</span> w)</span> </span>&#123;</div><div class="line">		Edge e = <span class="keyword">new</span> Edge(a, b, w);</div><div class="line">		Prim.EdgeQueue.add(e);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">primTree</span><span class="params">()</span></span>&#123;</div><div class="line">		buildGraph();</div><div class="line">		Vertex start = vertexList.get(<span class="number">0</span>);</div><div class="line">		newVertex.add(start);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;vertexList.size()-<span class="number">1</span>;n++)&#123;</div><div class="line">			Vertex temp = <span class="keyword">new</span> Vertex(start.key);</div><div class="line">			Edge tempedge = <span class="keyword">new</span> Edge(start,start,<span class="number">1000</span>);</div><div class="line">			<span class="keyword">for</span>(Vertex v : newVertex)&#123;</div><div class="line">				<span class="keyword">for</span>(Edge e : EdgeQueue)&#123;</div><div class="line">					<span class="keyword">if</span>(e.start==v &amp;&amp; !containVertex(e.end))&#123;</div><div class="line">						<span class="keyword">if</span>(e.key&lt;tempedge.key)&#123;</div><div class="line">							temp = e.end;</div><div class="line">							tempedge = e;</div><div class="line">						&#125;	</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			newVertex.add(temp);</div><div class="line">		&#125;</div><div class="line">		Iterator it = newVertex.iterator();</div><div class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">			Vertex v =(Vertex) it.next();</div><div class="line">			System.out.println(v.key);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containVertex</span><span class="params">(Vertex vte)</span></span>&#123;</div><div class="line">		<span class="keyword">for</span>(Vertex v : newVertex)&#123;</div><div class="line">			<span class="keyword">if</span>(v.key.equals(vte.key))</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> </span>&#123;</div><div class="line">	String key;</div><div class="line">	Vertex(String key)&#123;</div><div class="line">		<span class="keyword">this</span>.key = key;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span>&#123;</div><div class="line">	Vertex start;</div><div class="line">	Vertex end;</div><div class="line">	<span class="keyword">int</span> key;</div><div class="line">	Edge(Vertex start,Vertex end,<span class="keyword">int</span> key)&#123;</div><div class="line">		<span class="keyword">this</span>.start = start;</div><div class="line">		<span class="keyword">this</span>.end  = end;</div><div class="line">		<span class="keyword">this</span>.key = key;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>克鲁斯卡尔算法</code></p>
<blockquote>
<p>假设 N=（V, {E}）是连通网，则令最小生成树的初始状态为只有n个顶点而无边的非连通图 T={V,{}}，图中每个顶点自成一格连通分量。在 E 中选择代价最小的边，若该边依附的顶点落在 T 中不同的连通分量上，则将此边加入到T中，否则舍去此边而选择下一条代价最小的边。以此类推，直至T中所有顶点都在同一连通分量上为止。</p>
</blockquote>
<p>1、新建图G，G中拥有原图中相同的节点，但没有边<br>2、将原图中所有的边按权值从小到大排序<br>3、从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边到图G中<br>4、重复3，直至图G中所有的节点都在同一个连通分量中</p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><blockquote>
<p>对于网图来说，最短路径是指两个顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点式源点，最后一个顶点是终点。</p>
</blockquote>
<p>两种计算最短路径算法：迪杰斯特拉(Djikstra)算法和佛洛伊德算法</p>
<p><code>迪杰斯特拉(Djikstra)算法 O(n^2)</code><br>迪杰斯特拉算法并不是一下子求出开始节点到尾节点的最短路径，而是一步步求出它们之间顶点的最短路径，过程中都是基于已经求出的最短路径的基础上，求得更远顶点的最短路径，最终得到你要的结果。运用的是贪心算法，如果v1-&gt;..-&gt;vi-&gt;…-&gt;vn 是最短路径，那v1-&gt;vi,vi-&gt;vn也是最短路径。</p>
<p><code>佛洛依德算法 O(n^3)</code></p>
<blockquote>
<p>通过Floyd计算图G=(V,E)中各个顶点的最短路径时，需要引入一个矩阵S，矩阵S中的元素a[i][j]表示顶点i(第i个顶点)到顶点j(第j个顶点)的距离。<br>假设图G中顶点个数为N，则需要对矩阵S进行N次更新。初始时，矩阵S中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞。 接下来开始，对矩阵S进行N次更新。第1次更新时，如果”a[i][j]的距离” &gt; “a[i][0]+a[0][j]”(a[i][0]+a[0][j]表示”i与j之间经过第1个顶点的距离”)，则更新a[i][j]为”a[i][0]+a[0][j]”。 同理，第k次更新时，如果”a[i][j]的距离” &gt; “a[i][k]+a[k][j]”，则更新a[i][j]为”a[i][k]+a[k][j]”。更新N次之后，操作完成！<br>详见<a href="http://www.cnblogs.com/skywang12345/p/3711532.html" target="_blank" rel="external">佛洛依德算法</a>，算法推导过程就是构建矩阵的过程。</p>
</blockquote>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><blockquote>
<p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为AOV网(Activity On Vertex)。<br>设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列V1,V2…..,Vn满足若从顶点Vi到顶点Vj有一条路径，则在顶点序列中Vi必在Vj顶点之前。则我们称这样的顶点序列为拓扑序列。<br>所谓拓扑序列，其实就是对一个有向图构造拓扑序列的过程。</p>
</blockquote>
<p>拓扑排序：是将一个AOV网的各个顶点按一定顺序排列，要求满足若存在<vi，vj>，则排序中的顶点Vi必在顶点Vj之前。对于同一幅图，拓扑排序可有多个拓扑排序。</vi，vj></p>
<p>算法：<br>（1）从有向图中选择一个无前驱（入度为0）的顶点输出。<br>（2）删除此顶点，并删除已此顶点为为尾的弧。<br>（3）重复（1），（2）步骤，知道输出全部顶点或者AOV网中不存在入度为0的顶点。</p>
<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><blockquote>
<p>在一个表示工程的带权有向图中，用顶点表示事件，用有向图表示活动，用边上的权值表示活动的持续事件，这种这种有向图的边表示活动图，我们称之为AOE网(Activity On Edge Network)。<br>我们把路径上各个活动所持续的时间之和称为路径的长度，从原点到汇点具有最大长度的路径叫做关键路径，在关键路径上的活动叫关键活动。</p>
</blockquote>
<p>算法:<br>(1) 从开始顶点V0出发，假设ve(0)=0，然后按照拓扑有序求出其他各顶点i的最早开始时间ve(i)，如果得到拓扑序列中顶点数目小于图中的顶点数，则表示图中存在回路，算法结束，否则继续执行。<br>(2) 从结束顶点Vn出发，假设vl(n-1) = ve(n-1);然后求出各顶点i的最晚发生时间。<br>(3) 根据顶点的最早发生时间，和最晚发生时间，依次求出出每条弧的最早开始时间和最晚开始时间，如果两只相等，则为关键活动。关键活动组成的路径则为关键路径。</p>
<p>拓扑排序和关键路径 使用邻接表存储数据，最小生成树和最短路径用 邻接矩阵 存储数据。</p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[大话数据结构学习笔记（一）]]></title>
      <url>/2017/05/06/data_structure1/</url>
      <content type="html"><![CDATA[<p><strong>数据结构</strong>在面试中经常遇到，以前没有系统的梳理过，最近在看《大话数据结构》，所以想整理一些笔记，供日后参考。</p>
<p><img src="http://g-ec4.images-amazon.com/images/G/28/book/jiangwei201110/dahuashujuejiegou_778-300._V165998284_.jpg" alt=""></p>
<a id="more"></a>
<hr>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p> 是相互之间存在一种或多种特定关系的数据元素的集合，按照视点的不同，可分为:</p>
<blockquote>
<p><strong>逻辑结构</strong>：集合结构，线形结构，树形结构，图形结构<br><strong>物理结构</strong>：顺序存储结构，链式存储结构</p>
</blockquote>
<hr>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote>
<p>算法是解决问题的方法。</p>
</blockquote>
<p>五个特性：输入，输出，有穷性，确定性和可行性。<br>算法设计的要求：正确性，可读性，健壮性，时间效率高和存储量低<br>算法效率的度量方法：事后统计，事前分析<br>算法时间复杂度：一般采用大O记法，O(1)叫常数阶，O(n)线形阶，O（n^2）平方阶…</p>
<h3 id="推导大O的方法"><a href="#推导大O的方法" class="headerlink" title="推导大O的方法"></a><code>推导大O的方法</code></h3><p>1、用常数1取代运行时间中的所有加法常数<br>2、在修改后的运行次数函数中，只保留最高阶项<br>3、如果最高阶项存在且不是1，则去除与这个项相乘的常数</p>
<h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><table>
<thead>
<tr>
<th style="text-align:center">执行次数</th>
<th style="text-align:center">函数阶</th>
<th style="text-align:center">非正式术语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">常数阶</td>
</tr>
<tr>
<td style="text-align:center">2n+3</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">线形阶</td>
</tr>
<tr>
<td style="text-align:center">3n^2+2n+1</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">平方阶</td>
</tr>
<tr>
<td style="text-align:center">5logn+20</td>
<td style="text-align:center">O(logn)</td>
<td style="text-align:center">对数阶</td>
</tr>
<tr>
<td style="text-align:center">2n+3nlogn+19</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">nlogn阶</td>
</tr>
<tr>
<td style="text-align:center">6n^3+2n^2+3n+4</td>
<td style="text-align:center">O(n^3)</td>
<td style="text-align:center">立方阶</td>
</tr>
<tr>
<td style="text-align:center">2^n</td>
<td style="text-align:center">O(2^n)</td>
<td style="text-align:center">指数阶</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="线形表"><a href="#线形表" class="headerlink" title="线形表"></a>线形表</h2><blockquote>
<p>零个或多个数据元素的有限序列</p>
</blockquote>
<h3 id="线形表的顺序存储结构"><a href="#线形表的顺序存储结构" class="headerlink" title="线形表的顺序存储结构"></a>线形表的顺序存储结构</h3><blockquote>
<p>用一段地址连续的存储单元依次存储线形表的数据元素<br>    |a1|a2|……|a(i-1)|ai|……|an|</p>
</blockquote>
<p><code>顺序存储结构需要三个属性</code><br><strong>存储空间的起始位置</strong>：数组data，他的存储位置就是存储空间的存储位置。<br><strong>线形表的最大存储容量</strong>：数组长度MaxSize<br><strong>线形表的当前长度</strong>：length</p>
<p>第i个数据元素ai的存储位置可以由a1推算得出 LOC(ai) = LOC(a1)+(i-1)*c </p>
<p>因此存取的时间复杂度是O(1)，由于插入删除需要移动后面节点的位置，所以插入删除的时间复杂度是O(n)</p>
<h3 id="线形表的链式存储结构"><a href="#线形表的链式存储结构" class="headerlink" title="线形表的链式存储结构"></a>线形表的链式存储结构</h3><blockquote>
<p>用一组任意的存储单元存储线形表的数据元素，这组存储单元可以是连续的，也可以是不连续的<br>    |……|0900(头指针)|……|a1(地址0900)|0700|……|an|null|……|</p>
</blockquote>
<p>单链表插入与删除的时间复杂度是O(1)，存取的时间复杂度是O(n)</p>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><blockquote>
<p>一些早期的编程高级语言，如Basic，Fortran等，由于没有指针，无法实现链表结构，于是想出用数组来代替指针，这种链表叫静态链表，也叫游标实现法</p>
</blockquote>
<p>让数组的元素由两个数据域组成，data和cur，cur相当于单链表中的next指针，存放该元素的后继在数组中的位置。</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><blockquote>
<p>将单链表的终端节点由空指针改成指向头节点，使单链表形成一个环，这种头尾相连的单链表称为单循环链表，简称单链表</p>
</blockquote>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><blockquote>
<p>为了解决单向链表不能找前继节点的缺点而设计，在单链表的基础上再加一个指针，指向前继节点</p>
</blockquote>
<hr>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><blockquote>
<p>限定在表尾进行插入和删除操作的线形表。允许插入和删除的一段叫栈顶，另一端叫栈尾。 是后进先出（Last In First Out）的线形表，简称LIFO结构。</p>
</blockquote>
<h4 id="栈的顺序存储结构及实现"><a href="#栈的顺序存储结构及实现" class="headerlink" title="栈的顺序存储结构及实现"></a>栈的顺序存储结构及实现</h4><p>让数组下标为0的一端作为栈底，入栈和出栈的时间复杂度都是O(1)<br>对于两个相同类型的栈可以设置两栈共享空间，最大限度利用事先开辟的空间来操作：将两个栈的栈底分别设置为一个数组的两端，然后向中间靠拢。</p>
<h4 id="栈的链式存储结构及实现"><a href="#栈的链式存储结构及实现" class="headerlink" title="栈的链式存储结构及实现"></a>栈的链式存储结构及实现</h4><p>把栈顶设置在链表的头部，而且在这种结构中，头节点失去了意义，不需要头节点</p>
<hr>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><blockquote>
<p>只允许在一端进行插入操作，而在另一端进行删除操作的线形表，是一种先进先出（First In First Out）的线形表，简称FIFO结构</p>
</blockquote>
<p>队列的顺序存储结构的入队操作时间复杂度是O(1)，出队操作是O(n)<br>队列的链式存储结构其实就是单链表，只不过它只能尾进头出</p>
<hr>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><blockquote>
<p>由零个或多个字符组成的有限序列，又名字符串</p>
</blockquote>
<p>这里不做赘述，可以了解下这里的两个算法，<a href="http://www.csdn.net/allenalex/article/details/11721097" target="_blank" rel="external">朴素的模式匹配算法</a>和<a href="http://blog.csdn.net/allenalex/article/details/11726107" target="_blank" rel="external">KMP模式匹配算法</a></p>
<hr>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><blockquote>
<p>n(n&gt;=0) 个结点的有限集。 n=0时称为空树。在任意一个非空树中：<br>1、有且只有一个特定的称为根（Root）的结点；<br>2、当n&gt;1时其余结点可分为m（m&gt;0）个互不相交的有限集T1，T2…Tm，其中每个集合本身又是一个树，并且称为根的子树（SubTree）</p>
</blockquote>
<p>结点的最大层次称为树的高度或深度，子树的个数称为树的度</p>
<h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><p>1、双亲表示法 （data，parent）<br>2、孩子表示法 （data，child1，child2，child3…）<br>3、孩子兄弟表示法 （data，firstchild，rightsib）</p>
<h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><blockquote>
<p>二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）</p>
</blockquote>
<p><code>二叉树的性质</code><br>1、在二叉树的第i层至多由2^(i-1)个结点<br>2、在深度为k的二叉树至多由2^k-1个结点（k&gt;=1）<br>3、在任何一个二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1<br>4、具有n个结点的完全二叉树的深度为|logn+1|（|n|表示不大于n的最大整数）</p>
<p><code>二叉树的存储结构</code><br>1、二叉树的顺序存储结构：在一棵n个结点的完全二叉树中，从树根起，自上层到下层，每层从左至右，给所有结点编号，能得到一个反映整个二叉树结构的线性序列，如果不是完全二叉树<br>会造成空间上的浪费，所以一般只用于完全二叉树<br>2、二叉树的链式存储结构：二叉链表（lchild，data，rchild）</p>
<p><code>遍历二叉树</code>：前序遍历，中序遍历，后序遍历，层序遍历</p>
<p><code>线索二叉树</code>：二叉树添加了直接指向节点的前驱和后继的指针的二叉树称为线索二叉树</p>
<p><code>哈夫曼树</code>：哈夫曼树是一种带权路径长度最短的二叉树，也称为最优二叉树。下面用一幅图来说明。<br><img src="http://images.cnitblog.com/blog/311549/201309/19165401-f8340a5a1ee64e48aff958ce3d7f37b4.jpg" alt=""></p>
<blockquote>
<p>它们的带权路径长度分别为：<br>图a： WPL=5<em>2+7</em>2+2<em>2+13</em>2=54<br>图b： WPL=5<em>3+2</em>3+7<em>2+13</em>1=48<br>可见，图b的带权路径长度较小，我们可以证明图b就是哈夫曼树(也称为最优二叉树)</p>
</blockquote>
<p><code>哈夫曼树的构造(哈夫曼算法)</code><br>1.根据给定的n个权值{w1,w2,…,wn}构成二叉树集合F={T1,T2,…,Tn},其中每棵二叉树Ti中只有一个带权为wi的根结点,其左右子树为空.<br>2.在F中选取两棵根结点权值最小的树作为左右子树构造一棵新的二叉树,且置新的二叉树的根结点的权值为左右子树根结点的权值之和.<br>3.在F中删除这两棵树,同时将新的二叉树加入F中.<br>4.重复2、3,直到F只含有一棵树为止.(得到哈夫曼树)</p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java 代码执行linux命令]]></title>
      <url>/2017/03/10/java_execute_shell/</url>
      <content type="html"><![CDATA[<p>在做一个java执行pyhton脚本命令时在网上找了许多方案都不行，最后在stackoverflow上<br>找到，执行脚本的时候需要带上shell的版本，类似于bash，zsh。看了下服务器上的是zsh，<br><a id="more"></a><br>于是优化代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.xiamu.utils;</div><div class="line"><span class="keyword">import</span> org.slf4j.Logger;</div><div class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Description: 调用脚本帮助类</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> haoyuan.yang</div><div class="line"> * <span class="doctag">@version</span> 1.0</div><div class="line"> * <span class="doctag">@date</span>: 2017/3/10</div><div class="line"> * <span class="doctag">@since</span> JDK 1.8</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PythonUtil</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(PythonUtil.class);</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Description:调用系统命令</div><div class="line">	 *</div><div class="line">	 * <span class="doctag">@author</span> haoyuan.yang</div><div class="line">	 * <span class="doctag">@version</span> 1.0</div><div class="line">	 * <span class="doctag">@date</span>: 2017/3/10 17:55</div><div class="line">	 * <span class="doctag">@since</span> JDK 1.8</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeCommand</span><span class="params">(String command)</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Process proc = Runtime.getRuntime()</div><div class="line">					.exec(<span class="keyword">new</span> String[] &#123; <span class="string">"zsh"</span>, <span class="string">"-c"</span>, command &#125;);</div><div class="line">			proc.waitFor();</div><div class="line">			BufferedReader reader = <span class="keyword">new</span> BufferedReader(</div><div class="line">					<span class="keyword">new</span> InputStreamReader(proc.getInputStream()));</div><div class="line">			StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">			String line;</div><div class="line">			<span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">				sb.append(line).append(<span class="string">"\n"</span>);</div><div class="line">			&#125;</div><div class="line">			logger.info(<span class="string">"execute command &#123;&#125; , result is &#123;&#125;"</span>, command, sb.toString());</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			logger.info(<span class="string">"execute command &#123;&#125; fault, e=&#123;&#125;"</span>, command, e.getMessage());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[排序算法Java实现]]></title>
      <url>/2016/12/05/sort/</url>
      <content type="html"><![CDATA[<h3 id="冒泡排序-0-N-2"><a href="#冒泡排序-0-N-2" class="headerlink" title="冒泡排序 0(N^2)"></a>冒泡排序 0(N^2)</h3><p>执行非常慢，概念上最简单。最大的会一直被交换，冒泡上来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span>[] arrays = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span> &#125;;</div><div class="line"><span class="keyword">int</span> out, in;</div><div class="line"><span class="keyword">for</span> (out = arrays.length - <span class="number">1</span>; out &gt; <span class="number">1</span>; out--) &#123; <span class="comment">// outer loop(backward)</span></div><div class="line">    <span class="keyword">for</span> (in = <span class="number">0</span>; in &lt; out; in++) &#123; <span class="comment">// inter loop(forward)</span></div><div class="line">        <span class="keyword">if</span> (arrays[in] &gt; arrays[in + <span class="number">1</span>]) &#123; <span class="comment">// out of order</span></div><div class="line">            <span class="keyword">int</span> temp = arrays[in]; <span class="comment">// swap them</span></div><div class="line">            arrays[in] = arrays[in + <span class="number">1</span>];</div><div class="line">            arrays[in + <span class="number">1</span>] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<h3 id="选择排序0-N-2"><a href="#选择排序0-N-2" class="headerlink" title="选择排序0(N^2)"></a>选择排序0(N^2)</h3><p>比较所有的数据项，取出最小值，放左边。比较剩下的数据，取最小，放最左。。。。<br>内层循环中，每一个in的新位置，数据项a[in]和a[min]比较，如果a[in]更小，则min被赋值为in的值，这里只是下标，没交换。到一次内层循环结束，再交换数据项。这样，最小数据项就会一直被放在左边。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span>[] arrays = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span> &#125;;</div><div class="line"><span class="keyword">int</span> out, in, min, nElems = arrays.length;</div><div class="line"><span class="keyword">for</span> (out = <span class="number">0</span>; out &lt; nElems - <span class="number">1</span>; out++) &#123; <span class="comment">// outer loop</span></div><div class="line">    min = out; <span class="comment">// minimum</span></div><div class="line">    <span class="keyword">for</span> (in = out + <span class="number">1</span>; in &lt; nElems; in++) &#123; <span class="comment">// inner loop</span></div><div class="line">        <span class="keyword">if</span> (arrays[in] &lt; arrays[min]) &#123; <span class="comment">// if min greater</span></div><div class="line">            min = in; <span class="comment">// we have a new min</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> temp = arrays[out]; <span class="comment">// swap them</span></div><div class="line">    arrays[out] = arrays[min];</div><div class="line">    arrays[min] = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="插入排序-N-N-1-2-2"><a href="#插入排序-N-N-1-2-2" class="headerlink" title="插入排序 N*(N-1)/2 /2"></a>插入排序 N*(N-1)/2 /2</h3><p>假设左边部分已经排序好了，从某个位置(比如10)开始无序，将10赋值给一临时值，然后和前面的数据比较，如果9位置比10大，就9右移一位，继续和8比较。。。直到到数据的最左边或找到比10位置数据小的某数据，放在它的右边，10位置的数据就排好了。<br>在大多数情况下，插入算法仍然需要0(N^2)的时间，但比冒泡快一倍，比选择排序也还要快一点。经常被用在较复杂的排序算法的最后阶段，例如快速排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span>[] arrays = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span> &#125;;</div><div class="line"><span class="keyword">int</span> in, out, nElems = arrays.length;</div><div class="line"><span class="keyword">for</span> (out = <span class="number">1</span>; out &lt; nElems; out++) &#123; <span class="comment">// out is dividing line</span></div><div class="line">    <span class="keyword">int</span> temp = arrays[out]; <span class="comment">// remove marked item</span></div><div class="line">    in = out; <span class="comment">// start shifts at out</span></div><div class="line">    <span class="keyword">while</span> (in &gt; <span class="number">0</span> &amp;&amp; arrays[in - <span class="number">1</span>] &gt;= temp)<span class="comment">// until one is smaller,</span></div><div class="line">    &#123;</div><div class="line">        arrays[in] = arrays[in - <span class="number">1</span>];<span class="comment">// shift item right</span></div><div class="line">        --in;</div><div class="line">    &#125;</div><div class="line">    arrays[in] = temp; <span class="comment">// insert marked item</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="归并排序O-N-logN"><a href="#归并排序O-N-logN" class="headerlink" title="归并排序O(N logN)"></a>归并排序O(N logN)</h3><p>只要O(N logN)，而冒泡排序，选择排序，插入排序都要用O(N N);.<br>归并排序的思想是：将一个数组分成两半，然后分别排序，然后将数组的两半合并，合并的时候需要比较大小(合并的时候还要考虑两小数组还有没有数据，即有可能一边有，另一边没有)。至于如何排序1/2半的数组，当然是再分成两个1/4数组，再排序。。。直到分割的小数组只有1个数据项，不用排序了。这是用到递归的思想<br>归并排序的缺点，需要在存储器中有另一个大小等于被排序的数据项数目的空间，用来复制分割出来的小数组。<br>归并算法的效率由来：需要复制log<sub>2</sub><sup>N</sup>层(分子数组)，每一个层都是N个数据，所以是NxlogN.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] guibing() &#123;</div><div class="line">    <span class="keyword">int</span>[] arrays = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span> &#125;;</div><div class="line">    <span class="keyword">int</span>[] workSpace = <span class="keyword">new</span> <span class="keyword">int</span>[arrays.length];</div><div class="line">    recMergeSort(arrays, workSpace, <span class="number">0</span>, arrays.length - <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> arrays;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span>[] workPlace, <span class="keyword">int</span> lowPtr, <span class="keyword">int</span> highPtr, <span class="keyword">int</span> upperBound)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// workspace index</span></div><div class="line">    <span class="keyword">int</span> lowerBound = lowPtr;</div><div class="line">    <span class="keyword">int</span> mid = highPtr - <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> n = upperBound - lowerBound + <span class="number">1</span>; <span class="comment">// size of items</span></div><div class="line">    <span class="comment">// 两边都有</span></div><div class="line">    <span class="keyword">while</span> (lowPtr &lt;= mid &amp;&amp; highPtr &lt;= upperBound) &#123;</div><div class="line">        <span class="keyword">if</span> (source[lowPtr] &lt; source[highPtr]) &#123;</div><div class="line">            workPlace[j++] = source[lowPtr++];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            workPlace[j++] = source[highPtr++];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 只有左边</span></div><div class="line">    <span class="keyword">while</span> (lowPtr &lt;= mid) &#123;</div><div class="line">        workPlace[j++] = source[lowPtr++];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 只有右边</span></div><div class="line">    <span class="keyword">while</span> (highPtr &lt;= upperBound) &#123;</div><div class="line">        workPlace[j++] = source[highPtr++];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 把值复制到原对象</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</div><div class="line">        source[lowerBound + j] = workPlace[j];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recMergeSort</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span>[] workSpace, <span class="keyword">int</span> lowerBound, <span class="keyword">int</span> upperBound)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (lowerBound == upperBound) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int</span> mid = (lowerBound + upperBound) / <span class="number">2</span>;</div><div class="line">        recMergeSort(source, workSpace, lowerBound, mid);</div><div class="line">        recMergeSort(source, workSpace, mid + <span class="number">1</span>, upperBound);</div><div class="line">        merge(source, workSpace, lowerBound, mid + <span class="number">1</span>, upperBound);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序基于插入排序，但增加了一个新的特性，大大地提高了插入排序的执行效率。(希尔是个人名。。。)<br>改进的地方：插入算法中，如果一个数据比较小而居于最右边，那么它需要一个一个地移动所有中间的数据项，效率比较低。<br>希尔排序通过加入插入排序中元素之间的间隔，并在这些有间隔的元素中进行插入排序，从而使数据项能大跨度地移动。当这些数据项排过一趟序后，减小数据项的间隔。再进行排序，依次进行下去。间隔被称为增量，用h表示.<br>进行过几次增量排序后，所有的元素离它再最终有序序列中的位置相差不大，数组达到”基本有序”,这时再来插入排序，移动量非常小。<br>当h值很大的时候，数据项每一趟排序需要移动元素的个数很少，但数据项移动的距离很长，这是非常有效率的。当h减少时，每一趟排序需要移动的元素的个数增多，但是此时数据项已经接近于它们排序后最终的位置，这对于插入排序可以更有效率。<br>其中，h = h x 3 +1, h = (h -1) / 3,是经验值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span>[] arrays = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span> &#125;;</div><div class="line"><span class="keyword">int</span> inner, outer, nElems = arrays.length;</div><div class="line"><span class="keyword">int</span> temp;</div><div class="line"><span class="keyword">int</span> h = <span class="number">1</span>;</div><div class="line"><span class="keyword">while</span> (h &lt;= nElems / <span class="number">3</span>) &#123;</div><div class="line">    h = h * <span class="number">3</span> + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">while</span> (h &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (outer = h; outer &lt; nElems; outer++) &#123;</div><div class="line">        temp = arrays[outer];</div><div class="line">        inner = outer;</div><div class="line">        <span class="keyword">while</span> (inner &gt; h - <span class="number">1</span> &amp;&amp; arrays[inner - h] &gt;= temp) &#123;</div><div class="line">            arrays[inner] = arrays[inner - h];</div><div class="line">            inner -= h;</div><div class="line">        &#125;</div><div class="line">        arrays[inner] = temp;</div><div class="line">    &#125;</div><div class="line">    h = (h - <span class="number">1</span>) / <span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="划分算法"><a href="#划分算法" class="headerlink" title="划分算法"></a>划分算法</h3><p>划分是快速排序的根本机制，但是划分本身也是一个有用的操作，这里单讲划分的算法。<br>划分数据就是把数据分为两组，使所有关键字大于特定值的数据项在一组，使所有关键字小于特定值的数据项在另一组。</p>
<p>划分算法由两个指针开始工作，两个指针分别指向数组的两头。在左边的指针，leftPtr，向右移动，而在右边的指针，rightPtr，向左移动。<br>实际上，leftPtr初始化时是在第一个数据项的左边一位(-1)，rightPtr是在最后一个数据项的右边一位(size)，这是因为在工作之前，它们都要分别的加一和减一。<br>停止和交换：当leftPtr遇到比枢纽(特定值，划分值)小的数据项时，它继续右移，因为这个数据项的位置已经处在数组的正确一边了。但是，当遇到比枢纽大的数据项时，它就停下来。类似的，当rightPtr遇到小于枢纽的数据项时，它也停下来。两个内层的while循环，控制这个扫面过程，当两个都停下来时，要么指针到头要么遇到错误的数据(大小比较不对)，做交换(更换位置，正确排列了)。<br>当两个指针最终相遇的时候，划分过程结束，并且推出这个外层的while循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] huafen() &#123;</div><div class="line">    <span class="keyword">int</span>[] arrays = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span> &#125;;</div><div class="line">    sort(arrays, <span class="number">6</span>);</div><div class="line">    <span class="keyword">return</span> arrays;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] ary, <span class="keyword">int</span> base)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> right = ary.length - <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> leftpoint = left, rightpoint = right;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="comment">// 分成左右两边同时进行比较，一边从左向右，一边从右向左，</span></div><div class="line">        <span class="keyword">while</span> (leftpoint &lt; right &amp;&amp; ary[leftpoint++] &lt; base)</div><div class="line">            ; <span class="comment">// leftpoint大于right或ary[leftpoint]&gt;base停止循环</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (rightpoint &gt;= left &amp;&amp; ary[rightpoint--] &gt; base)</div><div class="line">            ; <span class="comment">// 反之</span></div><div class="line">        System.out.println(<span class="string">"左边需要交换的索引:"</span> + (leftpoint - <span class="number">1</span>));</div><div class="line">        System.out.println(<span class="string">"右边需要交换的索引:"</span> + (rightpoint + <span class="number">1</span>));</div><div class="line">        <span class="comment">// 上面拿到了不符合条件的两个索引，即需要交换的两个索引</span></div><div class="line">        <span class="keyword">if</span> (leftpoint - <span class="number">1</span> &lt; rightpoint + <span class="number">1</span>) &#123;<span class="comment">// 需要交换</span></div><div class="line">            <span class="keyword">int</span> temp = ary[leftpoint - <span class="number">1</span>];</div><div class="line">            ary[leftpoint - <span class="number">1</span>] = ary[rightpoint + <span class="number">1</span>];</div><div class="line">            ary[rightpoint + <span class="number">1</span>] = temp;</div><div class="line">            leftpoint = left;</div><div class="line">            rightpoint = right;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>最流行的排序算法，时间复杂度为O(N*logN)。虽然不觉得这种行为好，但有的公司喜欢笔试时让人手写快排(一些开发者如是说)。<br>原理是：把一个数组划分为两个子数组，这里用到划分算法，左子数组的数据项都小于右子数组的数据项，然后递归地调用自身为每个子数组进行快速排序来实现，最后使用插入排序。</p>
<p>在这个算法中划分的关键值(枢纽)的选择非常重要。<br>最初思想，选用数组最右边的值为pivot,进行一次划分，划分的结果就是left-&gt;mid-1, mid-&gt;right-1, right(这个位置的值是pivot)，三部分，然后交换mid和right的值(划分算法的leftPtr在停止时会停在mid位置)，这样pivot就到中间，而小于pivot的值全在左边，大于的值全在右边，数组的排序不受影响。<br>下面的排序从left到pivot-1,pivot+到right。中间项不参与划分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort() &#123;</div><div class="line">    <span class="keyword">int</span>[] arrays = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span> &#125;;</div><div class="line">    qsort(arrays, <span class="number">0</span>, arrays.length - <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> arrays;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</div><div class="line">        <span class="keyword">int</span> pivot = partition(arr, low, high); <span class="comment">// 将数组分为两部分</span></div><div class="line">        qsort(arr, low, pivot - <span class="number">1</span>); <span class="comment">// 递归排序左子数组</span></div><div class="line">        qsort(arr, pivot + <span class="number">1</span>, high); <span class="comment">// 递归排序右子数组</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> pivot = arr[low]; <span class="comment">// 枢轴记录</span></div><div class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</div><div class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot)</div><div class="line">            --high;</div><div class="line">        arr[low] = arr[high]; <span class="comment">// 交换比枢轴小的记录到左端</span></div><div class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot)</div><div class="line">            ++low;</div><div class="line">        arr[high] = arr[low]; <span class="comment">// 交换比枢轴小的记录到右端</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 扫描完成，枢轴到位</span></div><div class="line">    arr[low] = pivot;</div><div class="line">    <span class="comment">// 返回的是枢轴的位置</span></div><div class="line">    <span class="keyword">return</span> low;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>作者 <a href="http://weibo.com/u/2413072655?s_all=1&amp;is_all=1" target="_blank" rel="external">夏目</a><br>2016 年 12月 05日</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POI 导出大量数据到Excel]]></title>
      <url>/2016/05/06/poi/</url>
      <content type="html"><![CDATA[<p>最近在做一个excel导出功能的时候，发现一个很严重的性能问题，只能导出4W条，再多不仅特别慢，导不出来，可能还会内存溢出。于是查了下资料，发现是poi 3.8以前的版本不支持大批量数据的导出，<a href="http://poi.apache.org/spreadsheet/how-to.html#sxssf" target="_blank" rel="external">参考官方介绍</a><br>于是将jar包升级后，修改代码，最终能在5分钟内导出100W的数据。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExcelUtil</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleExcel</span><span class="params">()</span></span>&#123;</div><div class="line">		SXSSFWorkbook workbook = <span class="keyword">new</span> SXSSFWorkbook(<span class="number">1000</span>);</div><div class="line">        Sheet sheet = workbook.createSheet();</div><div class="line">		<span class="keyword">try</span></div><div class="line">        &#123;</div><div class="line"></div><div class="line">            Row  hSSFRowHead = sheet.createRow(<span class="number">0</span>);</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; headNames.length; i++)</div><div class="line">			&#123;</div><div class="line">            hSSFCell hSSFCell = hSSFRowHead.createCell(i, HSSFCell.CELL_TYPE_STRING);</div><div class="line">            hSSFCell.setCellValue(<span class="keyword">new</span> XSSFRichTextString(headNames[i]));</div><div class="line">			&#125;</div><div class="line">            List prdList = getExcelDataList();</div><div class="line">			<span class="keyword">for</span> (Object prd : prdList)</div><div class="line">            &#123;</div><div class="line">                Row hSSFRowData = sheet.createRow(count);</div><div class="line">                createDataRows(hSSFRowData, (Map) prd, headsName);</div><div class="line">				Cell hSSFCell;</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; headsName.length; i++)</div><div class="line">				&#123;</div><div class="line">					hSSFCell = hSSFRowData.createCell(i, HSSFCell.CELL_TYPE_STRING);</div><div class="line">					setStringValue(prd, headsName[i], hSSFCell);</div><div class="line">				&#125;</div><div class="line">				<span class="comment">//刷新内存</span></div><div class="line">                <span class="keyword">if</span> (count % <span class="number">1000</span> == <span class="number">0</span>)</div><div class="line">                &#123;</div><div class="line">                    ((SXSSFSheet) sheet).flushRows();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span> (Exception e)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">        &#125;</div><div class="line">        ByteArrayOutputStream ot = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">        workbook.write(ot);</div><div class="line">        <span class="comment">//不调用此方法会在tomcat/temp/poifiles下生成  **.xml文件，并且不会清理，调用清理临时文件</span></div><div class="line">        workbook.dispose();</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> POI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> POI </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo Tips]]></title>
      <url>/2016/04/09/tips/</url>
      <content type="html"><![CDATA[<p><img src="https://haymaicc.github.io/res/tips.png" alt=""></p>
<a id="more"></a>
<p>通过<a href="http://haymai.cc/2016/04/06/hexo/" target="_blank" rel="external">Hexo 安装教程</a>,我们已经能基本使用Hexo了。但是笔者在使用过程中还是遇到了一些问题，在这一篇中希望能总结一些经验，不能说是很有用的东西，也只是希望做一个记录。遇到了能在这里找到解决方法。</p>
<h3 id="代码提交到了Github上"><a href="#代码提交到了Github上" class="headerlink" title="代码提交到了Github上"></a>代码提交到了Github上</h3><p>我把hexo的源码和主题的修改都用<a href="https://github.com/haymaicc/xiamu/tree/master" target="_blank" rel="external">Git提交到了Github上</a>,如果想看本站源码可以down下来，Git具体操作<a href="http://1ke.co/course/194" target="_blank" rel="external">这篇文章</a>介绍的很详细，我也是通过这篇文章Get到套路的。</p>
<h3 id="Node-forever"><a href="#Node-forever" class="headerlink" title="Node forever"></a>Node forever</h3><p>在搭好环境后，我发现有时候莫名其妙的Hexo就挂了，然后整个网站就无法浏览，实际上通过Node forever 就可以解决这个问题，原理就是在后台用定时任务去跑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure></p>
<p>如果挂了就重启。具体怎么做呢？</p>
<blockquote>
<ul>
<li>通过<strong>npm</strong>安装forever</li>
<li>在hexo目录下写好一个javascript脚本</li>
<li>通过forever定时执行该脚本</li>
</ul>
</blockquote>
<p>1、通过<strong>npm</strong>安装forever，执行如下命令安装forever<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo npm install forever -g   #安装</div></pre></td></tr></table></figure></p>
<p>2、在hexo的根目录下新建一个haymai.js文件，内容如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn;</div><div class="line">free = spawn(<span class="string">'hexo'</span>, [<span class="string">'server'</span>, <span class="string">'-p 80'</span>]);</div><div class="line"></div><div class="line">free.stdout.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'standard output:\n'</span> + data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">free.stderr.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123; </div><div class="line"><span class="built_in">console</span>.log(<span class="string">'standard error output:\n'</span> + data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">free.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code, signal</span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'child process eixt ,exit:'</span> + code);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>3、执行如下命令跑定时任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ forever --minUptime 10000 --spinSleepTime 26000 start haymai.js</div></pre></td></tr></table></figure></p>
<h3 id="加入RSS和Sitemap"><a href="#加入RSS和Sitemap" class="headerlink" title="加入RSS和Sitemap"></a>加入RSS和Sitemap</h3><p>1、在Hexo根目录执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-generator-feed</div><div class="line">$ npm install hexo-generator-sitemap</div></pre></td></tr></table></figure></p>
<p>2、在Hexo根目录下加入<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Extensions</span></div><div class="line"><span class="attr">Plugins:</span></div><div class="line"><span class="bullet">-</span> hexo-generator-feed</div><div class="line"><span class="bullet">-</span> hexo-generator-sitemap</div><div class="line"></div><div class="line"><span class="comment">#Feed Atom</span></div><div class="line"><span class="attr">feed:</span></div><div class="line"><span class="attr">  type:</span> atom</div><div class="line"><span class="attr">  path:</span> atom.xml</div><div class="line"><span class="attr">  limit:</span> <span class="number">20</span></div><div class="line"></div><div class="line"><span class="comment">#sitemap</span></div><div class="line"><span class="attr">sitemap:</span></div><div class="line"><span class="attr">  path:</span> sitemap.xml</div></pre></td></tr></table></figure></p>
<p>3、执行hexo clean和hexo deploy 后，打开haymai.cc/atom.xml，haymai.cc/sitemap.xml即可看到已生效</p>
<h3 id="公益404页面"><a href="#公益404页面" class="headerlink" title="公益404页面"></a>公益404页面</h3><p><a href="haymai.cc/aaa">haymai.cc/aaa -&gt; 腾讯公益</a><br>这个真心蛋疼死了，网上大多数人说只要把一个404.html放进source文件夹就行了，但是我放了死活不行，结果找了半天，原来是用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure></p>
<p>启动的不会去跳转到404.html，这不就是说hexo 没有这功能？！ 最终我只好祭出杀手锏，抛弃 hexo启动，转而将public文件夹路径指向了tomcat ROOT应用，然后配置ROOT下的web.xml如下内容：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>当然source下的404.html 也要加上，这里用了腾旭公益404页面，内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">layout: false</div><div class="line">title: &quot;404&quot;</div><div class="line">---</div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt;</div><div class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;</div><div class="line">  &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt;</div><div class="line">  &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;http://www.haymai.cc&quot; homePageName=&quot;回到唐伯虎点蜡烛&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>不知道各位看官是怎么解决的，有没有更好的方法？</p>
<h3 id="网易云音乐引入"><a href="#网易云音乐引入" class="headerlink" title="网易云音乐引入"></a>网易云音乐引入</h3><p>哈哈，网站第一次发声，链的网易云，在页面上加入如下代码，你也能听我的红心啦~23333</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div style=&quot;max-width: 350px;max-height: 150px&quot;&gt;</div><div class="line">&lt;embed style=&quot;margin-top: -35px;&quot; frameborder=&quot;no&quot; border=&quot;0&quot;marginwidth=&quot;0&quot; marginheight=&quot;0&quot; src=&quot;https://music.163.com/outchain/player?type=0&amp;id=28560713&amp;auto=0&amp;height=90&quot;&gt;&lt;/embed&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<div style="max-width: 350px;max-height: 150px"><br><embed style="margin-top: -35px;" frameborder="no" border="0" marginwidth="0" marginheight="0" src="https://music.163.com/outchain/player?type=0&id=28560713&auto=1&height=90"><br></div>

<p>作者 <a href="http://weibo.com/u/2413072655?s_all=1&amp;is_all=1" target="_blank" rel="external">夏目</a><br>2016 年 04月 09日</p>
]]></content>
      
        <categories>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 安装教程]]></title>
      <url>/2016/04/06/hexo/</url>
      <content type="html"><![CDATA[<p>近来觉得需要一隅来发发牢骚，于是用Hexo搭建了这个博客。</p>
<p><img src="http://i.v2ex.co/5bb7J7NT.png" alt=""></p>
<a id="more"></a>
<p><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo官网</a>介绍的很酷炫，实际上用起来也让我觉得很强大，但是开发文档编写的相当羞涩，所以在这总结一下Hexo的安装教程，希望对大家有所帮助。</p>
<p>首先要想使用Hexo,有两个先决条件：</p>
<blockquote>
<p>安装Git(可以通过GitHub down 一些主题，还有一些源码)<br>安装node.js</p>
</blockquote>
<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>这个相当简单，通过 <a href="https://git-scm.com/download/linux/" target="_blank" rel="external">Git linux命令即可安装</a> ，但是笔者的用的阿里云suse版本的linux，使用Git官网的zypper软件源</p>
<pre><code>$ zypper install git</code></pre>

<p>安装不成功，遂在网上下载了源码，解压安装。</p>
<h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>安装 <a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a> </p>
<pre><code>$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh | bash</code></pre>
CURL安装node
<pre><code>$ curl https://raw.github.com/creationix/nvm/master/install.sh| sh</code></pre>
重启终端并执行下列命令即可安装 Node.js。
<pre><code>$ nvm install 4</code></pre>

<h3 id="所有必备的应用程序安装完成后，即可使用npm安装Hexo。"><a href="#所有必备的应用程序安装完成后，即可使用npm安装Hexo。" class="headerlink" title="所有必备的应用程序安装完成后，即可使用npm安装Hexo。"></a>所有必备的应用程序安装完成后，即可使用npm安装Hexo。</h3><p>如果第一条命令失败，可以试试 –unsafe那条命令安装。</p>
<pre><code>$ npm install -g hexo-cli
$ npm install --unsafe-perm -g hexo-cli</code></pre>

<h3 id="Hexo-基本操作"><a href="#Hexo-基本操作" class="headerlink" title="Hexo 基本操作"></a>Hexo 基本操作</h3><p>到这里Hexo的运行环境基本搭建完成，若是在安装过程中遇到一些依赖包找不到的情况，再用npm安装一些依赖包。<br>Hexo的简单操作，可以看官网的命令介绍 <a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="external">Hexo指令</a><br>通过</p>
<pre><code>$ hexo init [folder]</code></pre>
建立网站，folder就是hexo 要安装的文件夹，若不指定则在当前目录建立。值得一提的是在Hexo安装目录下有个_config.yml文件，可以配置Hexo的一些基本参数，如网站的标题什么的。
然后通过 
<pre><code>$ hexo new [layout]</code></pre>

<p>新建文章，layout默认有三种：post、page 和 draft，存在source/_posts 文件夹。<br>执行完new 命令会生成一个 xxx.md 文件，通过markdown来编写文章，附上 <a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">markdown在线编辑器</a></p>
<p>还有几个常用的 <strong>命令</strong></p>
<pre><code>$ hexo clean
$ hexo generate
$ hexo server -p 80</code></pre>

<p>用来清理和生成静态文件，以固定端口启动hexo</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>[1]:<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">Hexo Themes 主题下载</a>,通过如下命令下载到主题文件夹</p>
<pre><code>git clone git://github.com/SuperKieran/TKL [folder]</code></pre>
[2]:查看Hexo 进程
<pre><code>ps -aux | grep hexo</code></pre>


<hr>
<p>再一次感谢您花费时间阅读，祝您在这里记录、阅读、分享愉快！</p>
<p>作者 <a href="http://weibo.com/u/2413072655?s_all=1&amp;is_all=1" target="_blank" rel="external">夏目</a><br>2016 年 04月 06日</p>
]]></content>
      
        <categories>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
