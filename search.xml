<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[各种IO的区别]]></title>
      <url>/2017/05/07/IO/</url>
      <content type="html"><![CDATA[<h2 id="BIO（同步阻塞IO）"><a href="#BIO（同步阻塞IO）" class="headerlink" title="BIO（同步阻塞IO）"></a>BIO（同步阻塞IO）</h2><p>使用ServerSocket绑定IP地址和监听端口，客户端发起连接，通过三次握手建立连接，用socket来进行通信，通过输入输出流的方式来进行同步阻塞的通信<br>每次客户端发起连接请求，都会启动一个线程<br>线程数量：客户端并发访问数为1：1，由于线程是JAVA虚拟机中非常宝贵的资源，一旦线程数急剧增加，系统性能会急剧下降，导致线程栈溢出，创建新的线程失败，并最终导致宕机<br>所以在JDK1.4之前，人们想到了一种方法，即PIO方式</p>
<a id="more"></a>
<h2 id="PIO（伪异步阻塞IO）"><a href="#PIO（伪异步阻塞IO）" class="headerlink" title="PIO（伪异步阻塞IO）"></a>PIO（伪异步阻塞IO）</h2><p>使用线程池来处理客户端的请求<br>客户端个数：线程池最大线程数=M：N，其中M远大于N<br>在read和write的时候，还是IO阻塞的，只是把每个线程交由线程池来控制管理</p>
<h2 id="NIO（异步阻塞IO）"><a href="#NIO（异步阻塞IO）" class="headerlink" title="NIO（异步阻塞IO）"></a>NIO（异步阻塞IO）</h2><p>用NIO方式处理IO<br>使用多路复用器Selector来轮询每个通道Channel，当通道中有事件时就通知处理，不会阻塞<br>使用相当复杂</p>
<h2 id="AIO（真正的异步非阻塞IO）"><a href="#AIO（真正的异步非阻塞IO）" class="headerlink" title="AIO（真正的异步非阻塞IO）"></a>AIO（真正的异步非阻塞IO）</h2><p>NIO2.0引入了新的异步通道的概念，不需要使用多路复用器（Selector）对注册通道进行轮询即可实现异步读写，从而简化了NIO编程模型</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[大话数据结构学习笔记（二）]]></title>
      <url>/2017/05/07/data-structure2/</url>
      <content type="html"><![CDATA[<p><a href="https://haymaicc.github.io/2017/05/06/data_structure1/">笔记（一）的传送门</a></p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><blockquote>
<p>是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为G(V,E)，其中G表示一个图，V是图G中的顶点，E是图G中边的集合</p>
</blockquote>
<a id="more"></a>
<h3 id="关于图的一些术语解释"><a href="#关于图的一些术语解释" class="headerlink" title="关于图的一些术语解释"></a>关于图的一些术语解释</h3><p><code>顶点（Vertex）</code>：<br>图中的结点又称为顶点。 </p>
<p><code>无边图</code>：<br>若顶点Vi到Vj之间的边没有方向，则称这条边为无项边（Edge），用序偶对(Vi,Vj)标示。<br>对于下图无向图G1来说，G1=(V1, {E1})，其中顶点集合V1={A,B,C,D}；边集合E1={(A,B),(B,C),(C,D),(D,A),(A,C)}:<br><img src="http://images.cnitblog.com/blog/380281/201307/13102520-912a10a40eb347b1a550f60a4feaae02.png" alt=""></p>
<p><code>有向图</code>：<br>若从顶点Vi到Vj的边是有方向的，则成这条边为有向边，也称为弧（Arc）。用有序对（Vi，Vj）标示，Vi称为弧尾，Vj称为弧头。如果任意两条边之间都是有向的，则称该图为有向图。<br>有向图G2中，G2=（V2,{E2}），顶点集合（A,B,C,D）,弧集合E2={<a,d>,{B,A},<c,a>,<b,c>}.</b,c></c,a></a,d></p>
<p><code>有向和无向完全图</code><br><img src="http://img.blog.csdn.net/20131113203819437" alt=""></p>
<p><code>权（Weight）</code>：<br>有些图的边和弧有相关的数，这个数叫做权（Weight）。这些带权的图通常称为网（Network）</p>
<p><code>度（Degree）</code>：<br>无向图中顶点v的度是关联于该顶点的边的数目，记为TD(v)。<br>入度（Indegree）：若G为有向图，则把以顶点v为终点的边的数目，称为v的入度，记为ID(v)。<br>出度（Outdegree）：若G为有向图，则把以顶点v为始点的边的数目，称为v的出度，记为OD(v)。<br>如图①：A的度为3。<br>如图②：A的入度为2，出度为1，所以A的度为3。<br><img src="http://img.blog.csdn.net/20131113205232156" alt=""></p>
<p><code>子图（Subgraph</code>：<br>设G=(V,E)是一个图，若E’是E的子集，V’是V的子集，使得E’中的边仅与V’中顶点相关联，则图G’=(V’,E’)称为图G的子图。<br>如图：②为①的4个子图<br><img src="http://img.blog.csdn.net/20131112231539062" alt=""></p>
<p><code>路径（Path</code><br>无向图G=(V,E)中从顶点v到顶点v’的路径是一个顶点序列(v=vi0,vi1,…,vin=v’)，其中(vij-1,vij)∈E，1≤j≤n。有向图G=(V,E)中从顶点v到顶点v’的路径是一个顶点序列(v=vi0,vi1,…,vin=v’)，其中〈vij-1,vij〉∈E，1≤j≤n。<br>　简单路径：序列中顶点不重复出现的路径。<br>　环（Cycle）：又称回路，第一个顶点和最后一个顶点相同的路径。<br>　简单回路：又称简单环，除了第一个顶点和最后一个顶点外，其余顶点不重复的回路。</p>
<p><code>连通</code>：<br>在无向图G中，如果从顶点v到顶点v’有路径，则称v和v’是连通的。<br>    连通图（Connected Graph）：如果对于图中的任意两个顶点vi、vj∈V，vi和vj都是连通的，则称该图为连通图。<br>    连通分量（Connected Component）：无向图中的极大连通子图。<br>    强连通图：在有向图G中，如果对于每一对vi，vj∈V，vi≠vj，从vi到vj和从vj到vi都存在路径，则称G是强连通图。<br>    强连通分量：有向图中的极大连通子图<br><img src="http://img.blog.csdn.net/20131113205509265" alt=""></p>
<p><code>生成树（Spanning Tree）</code>：<br>含有连通图的全部顶点的一个极小连通子图。</p>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><p><code>邻接矩阵</code>：<br>图的邻接矩阵存储方式是用两个数组来标示图。一个一位数组存储图顶点的信息，一个二维数组（称为邻接矩阵）存储图中边或者弧的信息。</p>
<p>设图G有n个顶点，则邻接矩阵是一个n*n的方阵，定义为：<br><img src="http://images.cnitblog.com/blog/380281/201307/13102724-c49b3c87958e493696d55d3306597b5c.png" alt=""></p>
<p>实例如下，左图是一个无向图。右图是邻接矩阵表示：<br><img src="http://images.cnitblog.com/blog/380281/201307/13102739-ae381b43e0124cc7908c055f350dc03a.png" alt=""></p>
<p>无向网图的创建代码，时间复杂度为O{n + n2 + e}。</p>
<p><code>邻接表</code><br>用数组和链表结合的存储方式来标示图的方法称为邻接表。</p>
<blockquote>
<p>原理：（类似于树的孩子表示法的第三种存储方式）<br>图中顶点用一个一维数组存储，当然也可以用单链表存储。<br>图中每个顶点 Vi 的所有邻接点构成一个线性表，由于邻接点的个数不确定，所以我们选择用单链表来存储。无向图成为顶点vi的边表，有向图则称为顶点vi作为弧尾的出边表。</p>
</blockquote>
<p><img src="http://images.cnitblog.com/blog/380281/201307/13103212-bec29eec5fda4044a93ee18ee4c10607.png" alt=""></p>
<p><code>十字链表（OrthogonalList）</code><br>十字链表把邻接表与逆邻接表结合起来，解决了出度和入度的问题。</p>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><blockquote>
<p>从图中某个顶点出发访遍图中其余顶点，且使每个顶点仅被访问依次，这一过程叫做图的遍历.</p>
</blockquote>
<p>遍历方法： 深度优先遍历和广度优先遍历</p>
<p><code>深度优先遍历 O(n^2)</code>：从图中某个顶点出发v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先便利图，直到图中所有和v有相同路径的顶点都被访问。</p>
<p><code>广度优先遍历（Breadth_First_Search）O(n^2)</code> 又称为广度优先搜索，简称BFS</p>
<p>深度优先更适合目标比较明确，以找到目标为主要目的的情况。<br>广度优先更适合在不断扩大遍历范围时找到相对最优解的情况。</p>
<h3 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h3><p><code>最小生成树（普里姆算法 O(n^2)）</code></p>
<blockquote>
<p>我们把构造连通图的最小代价生成树称为最小生成树</p>
</blockquote>
<p>最小生成树实现算法：普利姆算法和克鲁斯卡尔算法</p>
<p><code>普利姆算法</code></p>
<blockquote>
<p>假设 N=(P, {E})是连通网， TE是N上最小生成树中边的集合。算法从 U={u0}（u0∈V），TE={}开始。重复执行下述操作：在所有 u∈U,v∈V-U的边（u,v）∈E中找一条代价最小的边（u0,v0）并入集合TE，同时v0并入U，直至U=V为止。此时TE中必有 n-1条边。则T=（V,{TE}）为最小生成树。</p>
</blockquote>
<p><code>克鲁斯卡尔算法</code></p>
<blockquote>
<p>假设 N=（V, {E}）是连通网，则令最小生成树的初始状态为只有n个顶点而无边的非连通图 T={V,{}}，图中每个顶点自成一格连通分量。在 E 中选择代价最小的边，若该边依附的顶点落在 T 中不同的连通分量上，则将此边加入到T中，否则舍去此边而选择下一条代价最小的边。以此类推，直至T中所有顶点都在同一连通分量上为止。</p>
</blockquote>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><blockquote>
<p>对于网图来说，最短路径是指两个顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点式源点，最后一个顶点是终点。</p>
</blockquote>
<p>两种计算最短路径算法：迪杰斯特拉(Djikstra)算法和佛洛伊德算法</p>
<p><code>迪杰斯特拉(Djikstra)算法 O(n^2)</code><br>迪杰斯特拉算法并不是一下子求出开始节点到尾节点的最短路径，而是一步步求出它们之间顶点的最短路径，过程中都是基于已经求出的最短路径的基础上，求得更远顶点的最短路径，最终得到你要的结果。</p>
<p><code>佛洛依德算法 O(n^3)</code></p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><blockquote>
<p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为AOV网(Activity On Vertex)。<br>设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列V1,V2…..,Vn满足若从顶点Vi到顶点Vj有一条路径，则在顶点序列中Vi必在Vj顶点之前。则我们称这样的顶点序列为拓扑序列。<br>所谓拓扑序列，其实就是对一个有向图构造拓扑序列的过程。</p>
</blockquote>
<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><blockquote>
<p>在一个表示工程的带权有向图中，用顶点表示事件，用有向图表示活动，用边上的权值表示活动的持续事件，这种这种有向图的边表示活动图，我们称之为AOE网(Activity On Edge Network)。<br>我们把路径上各个活动所持续的时间之和称为路径的长度，从原点到汇点具有最大长度的路径叫做关键路径，在关键路径上的活动叫关键活动。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[大话数据结构学习笔记（一）]]></title>
      <url>/2017/05/06/data_structure1/</url>
      <content type="html"><![CDATA[<p><strong>数据结构</strong>在面试中经常遇到，以前没有系统的梳理过，最近在看《大话数据结构》，所以想整理一些笔记，供日后参考。</p>
<p><img src="http://g-ec4.images-amazon.com/images/G/28/book/jiangwei201110/dahuashujuejiegou_778-300._V165998284_.jpg" alt=""></p>
<a id="more"></a>
<hr>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p> 是相互之间存在一种或多种特定关系的数据元素的集合，按照视点的不同，可分为:</p>
<blockquote>
<p><strong>逻辑结构</strong>：集合结构，线形结构，树形结构，图形结构<br><strong>物理结构</strong>：顺序存储结构，链式存储结构</p>
</blockquote>
<hr>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote>
<p>算法是解决问题的方法。</p>
</blockquote>
<p>五个特性：输入，输出，有穷性，确定性和可行性。<br>算法设计的要求：正确性，可读性，健壮性，时间效率高和存储量低<br>算法效率的度量方法：事后统计，事前分析<br>算法时间复杂度：一般采用大O记法，O(1)叫常数阶，O(n)线形阶，O（n^2）平方阶…</p>
<h3 id="推导大O的方法"><a href="#推导大O的方法" class="headerlink" title="推导大O的方法"></a><code>推导大O的方法</code></h3><p>1、用常数1取代运行时间中的所有加法常数<br>2、在修改后的运行次数函数中，只保留最高阶项<br>3、如果最高阶项存在且不是1，则去除与这个项相乘的常数</p>
<h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><table>
<thead>
<tr>
<th style="text-align:center">执行次数</th>
<th style="text-align:center">函数阶</th>
<th style="text-align:center">非正式术语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">常数阶</td>
</tr>
<tr>
<td style="text-align:center">2n+3</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">线形阶</td>
</tr>
<tr>
<td style="text-align:center">3n^2+2n+1</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">平方阶</td>
</tr>
<tr>
<td style="text-align:center">5logn+20</td>
<td style="text-align:center">O(logn)</td>
<td style="text-align:center">对数阶</td>
</tr>
<tr>
<td style="text-align:center">2n+3nlogn+19</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">nlogn阶</td>
</tr>
<tr>
<td style="text-align:center">6n^3+2n^2+3n+4</td>
<td style="text-align:center">O(n^3)</td>
<td style="text-align:center">立方阶</td>
</tr>
<tr>
<td style="text-align:center">2^n</td>
<td style="text-align:center">O(2^n)</td>
<td style="text-align:center">指数阶</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="线形表"><a href="#线形表" class="headerlink" title="线形表"></a>线形表</h2><blockquote>
<p>零个或多个数据元素的有限序列</p>
</blockquote>
<h3 id="线形表的顺序存储结构"><a href="#线形表的顺序存储结构" class="headerlink" title="线形表的顺序存储结构"></a>线形表的顺序存储结构</h3><blockquote>
<p>用一段地址连续的存储单元依次存储线形表的数据元素<br>    |a1|a2|……|a(i-1)|ai|……|an|</p>
</blockquote>
<p><code>顺序存储结构需要三个属性</code><br><strong>存储空间的起始位置</strong>：数组data，他的存储位置就是存储空间的存储位置。<br><strong>线形表的最大存储容量</strong>：数组长度MaxSize<br><strong>线形表的当前长度</strong>：length</p>
<p>第i个数据元素ai的存储位置可以由a1推算得出 LOC(ai) = LOC(a1)+(i-1)*c </p>
<p>因此存取的时间复杂度是O(1)，由于插入删除需要移动后面节点的位置，所以插入删除的时间复杂度是O(n)</p>
<h3 id="线形表的链式存储结构"><a href="#线形表的链式存储结构" class="headerlink" title="线形表的链式存储结构"></a>线形表的链式存储结构</h3><blockquote>
<p>用一组任意的存储单元存储线形表的数据元素，这组存储单元可以是连续的，也可以是不连续的<br>    |……|0900(头指针)|……|a1(地址0900)|0700|……|an|null|……|</p>
</blockquote>
<p>单链表插入与删除的时间复杂度是O(1)，存取的时间复杂度是O(n)</p>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><blockquote>
<p>一些早期的编程高级语言，如Basic，Fortran等，由于没有指针，无法实现链表结构，于是想出用数组来代替指针，这种链表叫静态链表，也叫游标实现法</p>
</blockquote>
<p>让数组的元素由两个数据域组成，data和cur，cur相当于单链表中的next指针，存放该元素的后继在数组中的位置。</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><blockquote>
<p>将单链表的终端节点由空指针改成指向头节点，使单链表形成一个环，这种头尾相连的单链表称为单循环链表，简称单链表</p>
</blockquote>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><blockquote>
<p>为了解决单向链表不能找前继节点的缺点而设计，在单链表的基础上再加一个指针，指向前继节点</p>
</blockquote>
<hr>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><blockquote>
<p>限定在表尾进行插入和删除操作的线形表。允许插入和删除的一段叫栈顶，另一端叫栈尾。 是后进先出（Last In First Out）的线形表，简称LIFO结构。</p>
</blockquote>
<h4 id="栈的顺序存储结构及实现"><a href="#栈的顺序存储结构及实现" class="headerlink" title="栈的顺序存储结构及实现"></a>栈的顺序存储结构及实现</h4><p>让数组下标为0的一端作为栈底，入栈和出栈的时间复杂度都是O(1)<br>对于两个相同类型的栈可以设置两栈共享空间，最大限度利用事先开辟的空间来操作：将两个栈的栈底分别设置为一个数组的两端，然后向中间靠拢。</p>
<h4 id="栈的链式存储结构及实现"><a href="#栈的链式存储结构及实现" class="headerlink" title="栈的链式存储结构及实现"></a>栈的链式存储结构及实现</h4><p>把栈顶设置在链表的头部，而且在这种结构中，头节点失去了意义，不需要头节点</p>
<hr>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><blockquote>
<p>只允许在一端进行插入操作，而在另一端进行删除操作的线形表，是一种先进先出（First In First Out）的线形表，简称FIFO结构</p>
</blockquote>
<p>队列的顺序存储结构的入队操作时间复杂度是O(1)，出队操作是O(n)<br>队列的链式存储结构其实就是单链表，只不过它只能尾进头出</p>
<hr>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><blockquote>
<p>由零个或多个字符组成的有限序列，又名字符串</p>
</blockquote>
<p>这里不做赘述，可以了解下这里的两个算法，<a href="http://www.csdn.net/allenalex/article/details/11721097" target="_blank" rel="external">朴素的模式匹配算法</a>和<a href="http://blog.csdn.net/allenalex/article/details/11726107" target="_blank" rel="external">KMP模式匹配算法</a></p>
<hr>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><blockquote>
<p>n(n&gt;=0) 个结点的有限集。 n=0时称为空树。在任意一个非空树中：<br>1、有且只有一个特定的称为根（Root）的结点；<br>2、当n&gt;1时其余结点可分为m（m&gt;0）个互不相交的有限集T1，T2…Tm，其中每个集合本身又是一个树，并且称为根的子树（SubTree）</p>
</blockquote>
<p>结点的最大层次称为树的高度或深度，子树的个数称为树的度</p>
<h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><p>1、双亲表示法 （data，parent）<br>2、孩子表示法 （data，child1，child2，child3…）<br>3、孩子兄弟表示法 （data，firstchild，rightsib）</p>
<h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><blockquote>
<p>二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）</p>
</blockquote>
<p><code>二叉树的性质</code><br>1、在二叉树的第i层至多由2^(i-1)个结点<br>2、在深度为k的二叉树至多由2^k-1个结点（k&gt;=1）<br>3、在任何一个二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1<br>4、具有n个结点的完全二叉树的深度为|logn+1|（|n|表示不大于n的最大整数）</p>
<p><code>二叉树的存储结构</code><br>1、二叉树的顺序存储结构：在一棵n个结点的完全二叉树中，从树根起，自上层到下层，每层从左至右，给所有结点编号，能得到一个反映整个二叉树结构的线性序列，如果不是完全二叉树<br>会造成空间上的浪费，所以一般只用于完全二叉树<br>2、二叉树的链式存储结构：二叉链表（lchild，data，rchild）</p>
<p><code>遍历二叉树</code>：前序遍历，中序遍历，后序遍历，层序遍历</p>
<p><code>线索二叉树</code>：二叉树添加了直接指向节点的前驱和后继的指针的二叉树称为线索二叉树</p>
<p><code>哈夫曼树</code>：哈夫曼树是一种带权路径长度最短的二叉树，也称为最优二叉树。下面用一幅图来说明。<br><img src="http://images.cnitblog.com/blog/311549/201309/19165401-f8340a5a1ee64e48aff958ce3d7f37b4.jpg" alt=""></p>
<blockquote>
<p>它们的带权路径长度分别为：<br>图a： WPL=5<em>2+7</em>2+2<em>2+13</em>2=54<br>图b： WPL=5<em>3+2</em>3+7<em>2+13</em>1=48<br>可见，图b的带权路径长度较小，我们可以证明图b就是哈夫曼树(也称为最优二叉树)</p>
</blockquote>
<p><code>哈夫曼树的构造(哈夫曼算法)</code><br>1.根据给定的n个权值{w1,w2,…,wn}构成二叉树集合F={T1,T2,…,Tn},其中每棵二叉树Ti中只有一个带权为wi的根结点,其左右子树为空.<br>2.在F中选取两棵根结点权值最小的树作为左右子树构造一棵新的二叉树,且置新的二叉树的根结点的权值为左右子树根结点的权值之和.<br>3.在F中删除这两棵树,同时将新的二叉树加入F中.<br>4.重复2、3,直到F只含有一棵树为止.(得到哈夫曼树)</p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java 代码执行linux命令]]></title>
      <url>/2017/03/10/java_execute_shell/</url>
      <content type="html"><![CDATA[<p>在做一个java执行pyhton脚本命令时在网上找了许多方案都不行，最后在stackoverflow上<br>找到，执行脚本的时候需要带上shell的版本，类似于bash，zsh。看了下服务器上的是zsh，<br><a id="more"></a><br>于是优化代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.xiamu.utils;</div><div class="line"><span class="keyword">import</span> org.slf4j.Logger;</div><div class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Description: 调用脚本帮助类</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> haoyuan.yang</div><div class="line"> * <span class="doctag">@version</span> 1.0</div><div class="line"> * <span class="doctag">@date</span>: 2017/3/10</div><div class="line"> * <span class="doctag">@since</span> JDK 1.8</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PythonUtil</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(PythonUtil.class);</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Description:调用系统命令</div><div class="line">	 *</div><div class="line">	 * <span class="doctag">@author</span> haoyuan.yang</div><div class="line">	 * <span class="doctag">@version</span> 1.0</div><div class="line">	 * <span class="doctag">@date</span>: 2017/3/10 17:55</div><div class="line">	 * <span class="doctag">@since</span> JDK 1.8</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeCommand</span><span class="params">(String command)</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Process proc = Runtime.getRuntime()</div><div class="line">					.exec(<span class="keyword">new</span> String[] &#123; <span class="string">"zsh"</span>, <span class="string">"-c"</span>, command &#125;);</div><div class="line">			proc.waitFor();</div><div class="line">			BufferedReader reader = <span class="keyword">new</span> BufferedReader(</div><div class="line">					<span class="keyword">new</span> InputStreamReader(proc.getInputStream()));</div><div class="line">			StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">			String line;</div><div class="line">			<span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">				sb.append(line).append(<span class="string">"\n"</span>);</div><div class="line">			&#125;</div><div class="line">			logger.info(<span class="string">"execute command &#123;&#125; , result is &#123;&#125;"</span>, command, sb.toString());</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			logger.info(<span class="string">"execute command &#123;&#125; fault, e=&#123;&#125;"</span>, command, e.getMessage());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[排序算法Java实现]]></title>
      <url>/2016/12/05/sort/</url>
      <content type="html"><![CDATA[<h3 id="冒泡排序-0-N-2"><a href="#冒泡排序-0-N-2" class="headerlink" title="冒泡排序 0(N^2)"></a>冒泡排序 0(N^2)</h3><p>执行非常慢，概念上最简单。最大的会一直被交换，冒泡上来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span>[] arrays = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span> &#125;;</div><div class="line"><span class="keyword">int</span> out, in;</div><div class="line"><span class="keyword">for</span> (out = arrays.length - <span class="number">1</span>; out &gt; <span class="number">1</span>; out--) &#123; <span class="comment">// outer loop(backward)</span></div><div class="line">    <span class="keyword">for</span> (in = <span class="number">0</span>; in &lt; out; in++) &#123; <span class="comment">// inter loop(forward)</span></div><div class="line">        <span class="keyword">if</span> (arrays[in] &gt; arrays[in + <span class="number">1</span>]) &#123; <span class="comment">// out of order</span></div><div class="line">            <span class="keyword">int</span> temp = arrays[in]; <span class="comment">// swap them</span></div><div class="line">            arrays[in] = arrays[in + <span class="number">1</span>];</div><div class="line">            arrays[in + <span class="number">1</span>] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<h3 id="选择排序0-N-2"><a href="#选择排序0-N-2" class="headerlink" title="选择排序0(N^2)"></a>选择排序0(N^2)</h3><p>比较所有的数据项，取出最小值，放左边。比较剩下的数据，取最小，放最左。。。。<br>内层循环中，每一个in的新位置，数据项a[in]和a[min]比较，如果a[in]更小，则min被赋值为in的值，这里只是下标，没交换。到一次内层循环结束，再交换数据项。这样，最小数据项就会一直被放在左边。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span>[] arrays = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span> &#125;;</div><div class="line"><span class="keyword">int</span> out, in, min, nElems = arrays.length;</div><div class="line"><span class="keyword">for</span> (out = <span class="number">0</span>; out &lt; nElems - <span class="number">1</span>; out++) &#123; <span class="comment">// outer loop</span></div><div class="line">    min = out; <span class="comment">// minimum</span></div><div class="line">    <span class="keyword">for</span> (in = out + <span class="number">1</span>; in &lt; nElems; in++) &#123; <span class="comment">// inner loop</span></div><div class="line">        <span class="keyword">if</span> (arrays[in] &lt; arrays[min]) &#123; <span class="comment">// if min greater</span></div><div class="line">            min = in; <span class="comment">// we have a new min</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> temp = arrays[out]; <span class="comment">// swap them</span></div><div class="line">    arrays[out] = arrays[min];</div><div class="line">    arrays[min] = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="插入排序-N-N-1-2-2"><a href="#插入排序-N-N-1-2-2" class="headerlink" title="插入排序 N*(N-1)/2 /2"></a>插入排序 N*(N-1)/2 /2</h3><p>假设左边部分已经排序好了，从某个位置(比如10)开始无序，将10赋值给一临时值，然后和前面的数据比较，如果9位置比10大，就9右移一位，继续和8比较。。。直到到数据的最左边或找到比10位置数据小的某数据，放在它的右边，10位置的数据就排好了。<br>在大多数情况下，插入算法仍然需要0(N^2)的时间，但比冒泡快一倍，比选择排序也还要快一点。经常被用在较复杂的排序算法的最后阶段，例如快速排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span>[] arrays = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span> &#125;;</div><div class="line"><span class="keyword">int</span> in, out, nElems = arrays.length;</div><div class="line"><span class="keyword">for</span> (out = <span class="number">1</span>; out &lt; nElems; out++) &#123; <span class="comment">// out is dividing line</span></div><div class="line">    <span class="keyword">int</span> temp = arrays[out]; <span class="comment">// remove marked item</span></div><div class="line">    in = out; <span class="comment">// start shifts at out</span></div><div class="line">    <span class="keyword">while</span> (in &gt; <span class="number">0</span> &amp;&amp; arrays[in - <span class="number">1</span>] &gt;= temp)<span class="comment">// until one is smaller,</span></div><div class="line">    &#123;</div><div class="line">        arrays[in] = arrays[in - <span class="number">1</span>];<span class="comment">// shift item right</span></div><div class="line">        --in;</div><div class="line">    &#125;</div><div class="line">    arrays[in] = temp; <span class="comment">// insert marked item</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="归并排序O-N-logN"><a href="#归并排序O-N-logN" class="headerlink" title="归并排序O(N logN)"></a>归并排序O(N logN)</h3><p>只要O(N logN)，而冒泡排序，选择排序，插入排序都要用O(N N);.<br>归并排序的思想是：将一个数组分成两半，然后分别排序，然后将数组的两半合并，合并的时候需要比较大小(合并的时候还要考虑两小数组还有没有数据，即有可能一边有，另一边没有)。至于如何排序1/2半的数组，当然是再分成两个1/4数组，再排序。。。直到分割的小数组只有1个数据项，不用排序了。这是用到递归的思想<br>归并排序的缺点，需要在存储器中有另一个大小等于被排序的数据项数目的空间，用来复制分割出来的小数组。<br>归并算法的效率由来：需要复制log<sub>2</sub><sup>N</sup>层(分子数组)，每一个层都是N个数据，所以是NxlogN.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] guibing() &#123;</div><div class="line">    <span class="keyword">int</span>[] arrays = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span> &#125;;</div><div class="line">    <span class="keyword">int</span>[] workSpace = <span class="keyword">new</span> <span class="keyword">int</span>[arrays.length];</div><div class="line">    recMergeSort(arrays, workSpace, <span class="number">0</span>, arrays.length - <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> arrays;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span>[] workPlace, <span class="keyword">int</span> lowPtr, <span class="keyword">int</span> highPtr, <span class="keyword">int</span> upperBound)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// workspace index</span></div><div class="line">    <span class="keyword">int</span> lowerBound = lowPtr;</div><div class="line">    <span class="keyword">int</span> mid = highPtr - <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> n = upperBound - lowerBound + <span class="number">1</span>; <span class="comment">// size of items</span></div><div class="line">    <span class="comment">// 两边都有</span></div><div class="line">    <span class="keyword">while</span> (lowPtr &lt;= mid &amp;&amp; highPtr &lt;= upperBound) &#123;</div><div class="line">        <span class="keyword">if</span> (source[lowPtr] &lt; source[highPtr]) &#123;</div><div class="line">            workPlace[j++] = source[lowPtr++];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            workPlace[j++] = source[highPtr++];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 只有左边</span></div><div class="line">    <span class="keyword">while</span> (lowPtr &lt;= mid) &#123;</div><div class="line">        workPlace[j++] = source[lowPtr++];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 只有右边</span></div><div class="line">    <span class="keyword">while</span> (highPtr &lt;= upperBound) &#123;</div><div class="line">        workPlace[j++] = source[highPtr++];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 把值复制到原对象</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</div><div class="line">        source[lowerBound + j] = workPlace[j];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recMergeSort</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span>[] workSpace, <span class="keyword">int</span> lowerBound, <span class="keyword">int</span> upperBound)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (lowerBound == upperBound) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int</span> mid = (lowerBound + upperBound) / <span class="number">2</span>;</div><div class="line">        recMergeSort(source, workSpace, lowerBound, mid);</div><div class="line">        recMergeSort(source, workSpace, mid + <span class="number">1</span>, upperBound);</div><div class="line">        merge(source, workSpace, lowerBound, mid + <span class="number">1</span>, upperBound);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序基于插入排序，但增加了一个新的特性，大大地提高了插入排序的执行效率。(希尔是个人名。。。)<br>改进的地方：插入算法中，如果一个数据比较小而居于最右边，那么它需要一个一个地移动所有中间的数据项，效率比较低。<br>希尔排序通过加入插入排序中元素之间的间隔，并在这些有间隔的元素中进行插入排序，从而使数据项能大跨度地移动。当这些数据项排过一趟序后，减小数据项的间隔。再进行排序，依次进行下去。间隔被称为增量，用h表示.<br>进行过几次增量排序后，所有的元素离它再最终有序序列中的位置相差不大，数组达到”基本有序”,这时再来插入排序，移动量非常小。<br>当h值很大的时候，数据项每一趟排序需要移动元素的个数很少，但数据项移动的距离很长，这是非常有效率的。当h减少时，每一趟排序需要移动的元素的个数增多，但是此时数据项已经接近于它们排序后最终的位置，这对于插入排序可以更有效率。<br>其中，h = h x 3 +1, h = (h -1) / 3,是经验值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span>[] arrays = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span> &#125;;</div><div class="line"><span class="keyword">int</span> inner, outer, nElems = arrays.length;</div><div class="line"><span class="keyword">int</span> temp;</div><div class="line"><span class="keyword">int</span> h = <span class="number">1</span>;</div><div class="line"><span class="keyword">while</span> (h &lt;= nElems / <span class="number">3</span>) &#123;</div><div class="line">    h = h * <span class="number">3</span> + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">while</span> (h &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (outer = h; outer &lt; nElems; outer++) &#123;</div><div class="line">        temp = arrays[outer];</div><div class="line">        inner = outer;</div><div class="line">        <span class="keyword">while</span> (inner &gt; h - <span class="number">1</span> &amp;&amp; arrays[inner - h] &gt;= temp) &#123;</div><div class="line">            arrays[inner] = arrays[inner - h];</div><div class="line">            inner -= h;</div><div class="line">        &#125;</div><div class="line">        arrays[inner] = temp;</div><div class="line">    &#125;</div><div class="line">    h = (h - <span class="number">1</span>) / <span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="划分算法"><a href="#划分算法" class="headerlink" title="划分算法"></a>划分算法</h3><p>划分是快速排序的根本机制，但是划分本身也是一个有用的操作，这里单讲划分的算法。<br>划分数据就是把数据分为两组，使所有关键字大于特定值的数据项在一组，使所有关键字小于特定值的数据项在另一组。</p>
<p>划分算法由两个指针开始工作，两个指针分别指向数组的两头。在左边的指针，leftPtr，向右移动，而在右边的指针，rightPtr，向左移动。<br>实际上，leftPtr初始化时是在第一个数据项的左边一位(-1)，rightPtr是在最后一个数据项的右边一位(size)，这是因为在工作之前，它们都要分别的加一和减一。<br>停止和交换：当leftPtr遇到比枢纽(特定值，划分值)小的数据项时，它继续右移，因为这个数据项的位置已经处在数组的正确一边了。但是，当遇到比枢纽大的数据项时，它就停下来。类似的，当rightPtr遇到小于枢纽的数据项时，它也停下来。两个内层的while循环，控制这个扫面过程，当两个都停下来时，要么指针到头要么遇到错误的数据(大小比较不对)，做交换(更换位置，正确排列了)。<br>当两个指针最终相遇的时候，划分过程结束，并且推出这个外层的while循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] huafen() &#123;</div><div class="line">    <span class="keyword">int</span>[] arrays = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span> &#125;;</div><div class="line">    sort(arrays, <span class="number">6</span>);</div><div class="line">    <span class="keyword">return</span> arrays;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] ary, <span class="keyword">int</span> base)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> right = ary.length - <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> leftpoint = left, rightpoint = right;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="comment">// 分成左右两边同时进行比较，一边从左向右，一边从右向左，</span></div><div class="line">        <span class="keyword">while</span> (leftpoint &lt; right &amp;&amp; ary[leftpoint++] &lt; base)</div><div class="line">            ; <span class="comment">// leftpoint大于right或ary[leftpoint]&gt;base停止循环</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (rightpoint &gt;= left &amp;&amp; ary[rightpoint--] &gt; base)</div><div class="line">            ; <span class="comment">// 反之</span></div><div class="line">        System.out.println(<span class="string">"左边需要交换的索引:"</span> + (leftpoint - <span class="number">1</span>));</div><div class="line">        System.out.println(<span class="string">"右边需要交换的索引:"</span> + (rightpoint + <span class="number">1</span>));</div><div class="line">        <span class="comment">// 上面拿到了不符合条件的两个索引，即需要交换的两个索引</span></div><div class="line">        <span class="keyword">if</span> (leftpoint - <span class="number">1</span> &lt; rightpoint + <span class="number">1</span>) &#123;<span class="comment">// 需要交换</span></div><div class="line">            <span class="keyword">int</span> temp = ary[leftpoint - <span class="number">1</span>];</div><div class="line">            ary[leftpoint - <span class="number">1</span>] = ary[rightpoint + <span class="number">1</span>];</div><div class="line">            ary[rightpoint + <span class="number">1</span>] = temp;</div><div class="line">            leftpoint = left;</div><div class="line">            rightpoint = right;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>最流行的排序算法，时间复杂度为O(N*logN)。虽然不觉得这种行为好，但有的公司喜欢笔试时让人手写快排(一些开发者如是说)。<br>原理是：把一个数组划分为两个子数组，这里用到划分算法，左子数组的数据项都小于右子数组的数据项，然后递归地调用自身为每个子数组进行快速排序来实现，最后使用插入排序。</p>
<p>在这个算法中划分的关键值(枢纽)的选择非常重要。<br>最初思想，选用数组最右边的值为pivot,进行一次划分，划分的结果就是left-&gt;mid-1, mid-&gt;right-1, right(这个位置的值是pivot)，三部分，然后交换mid和right的值(划分算法的leftPtr在停止时会停在mid位置)，这样pivot就到中间，而小于pivot的值全在左边，大于的值全在右边，数组的排序不受影响。<br>下面的排序从left到pivot-1,pivot+到right。中间项不参与划分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort() &#123;</div><div class="line">    <span class="keyword">int</span>[] arrays = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span> &#125;;</div><div class="line">    qsort(arrays, <span class="number">0</span>, arrays.length - <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> arrays;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</div><div class="line">        <span class="keyword">int</span> pivot = partition(arr, low, high); <span class="comment">// 将数组分为两部分</span></div><div class="line">        qsort(arr, low, pivot - <span class="number">1</span>); <span class="comment">// 递归排序左子数组</span></div><div class="line">        qsort(arr, pivot + <span class="number">1</span>, high); <span class="comment">// 递归排序右子数组</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> pivot = arr[low]; <span class="comment">// 枢轴记录</span></div><div class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</div><div class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot)</div><div class="line">            --high;</div><div class="line">        arr[low] = arr[high]; <span class="comment">// 交换比枢轴小的记录到左端</span></div><div class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot)</div><div class="line">            ++low;</div><div class="line">        arr[high] = arr[low]; <span class="comment">// 交换比枢轴小的记录到右端</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 扫描完成，枢轴到位</span></div><div class="line">    arr[low] = pivot;</div><div class="line">    <span class="comment">// 返回的是枢轴的位置</span></div><div class="line">    <span class="keyword">return</span> low;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>作者 <a href="http://weibo.com/u/2413072655?s_all=1&amp;is_all=1" target="_blank" rel="external">夏目</a><br>2016 年 12月 05日</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POI 导出大量数据到Excel]]></title>
      <url>/2016/05/06/poi/</url>
      <content type="html"><![CDATA[<p>最近在做一个excel导出功能的时候，发现一个很严重的性能问题，只能导出4W条，再多不仅特别慢，导不出来，可能还会内存溢出。于是查了下资料，发现是poi 3.8以前的版本不支持大批量数据的导出，<a href="http://poi.apache.org/spreadsheet/how-to.html#sxssf" target="_blank" rel="external">参考官方介绍</a><br>于是将jar包升级后，修改代码，最终能在5分钟内导出100W的数据。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExcelUtil</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleExcel</span><span class="params">()</span></span>&#123;</div><div class="line">		SXSSFWorkbook workbook = <span class="keyword">new</span> SXSSFWorkbook(<span class="number">1000</span>);</div><div class="line">        Sheet sheet = workbook.createSheet();</div><div class="line">		<span class="keyword">try</span></div><div class="line">        &#123;</div><div class="line"></div><div class="line">            Row  hSSFRowHead = sheet.createRow(<span class="number">0</span>);</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; headNames.length; i++)</div><div class="line">			&#123;</div><div class="line">            hSSFCell hSSFCell = hSSFRowHead.createCell(i, HSSFCell.CELL_TYPE_STRING);</div><div class="line">            hSSFCell.setCellValue(<span class="keyword">new</span> XSSFRichTextString(headNames[i]));</div><div class="line">			&#125;</div><div class="line">            List prdList = getExcelDataList();</div><div class="line">			<span class="keyword">for</span> (Object prd : prdList)</div><div class="line">            &#123;</div><div class="line">                Row hSSFRowData = sheet.createRow(count);</div><div class="line">                createDataRows(hSSFRowData, (Map) prd, headsName);</div><div class="line">				Cell hSSFCell;</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; headsName.length; i++)</div><div class="line">				&#123;</div><div class="line">					hSSFCell = hSSFRowData.createCell(i, HSSFCell.CELL_TYPE_STRING);</div><div class="line">					setStringValue(prd, headsName[i], hSSFCell);</div><div class="line">				&#125;</div><div class="line">				<span class="comment">//刷新内存</span></div><div class="line">                <span class="keyword">if</span> (count % <span class="number">1000</span> == <span class="number">0</span>)</div><div class="line">                &#123;</div><div class="line">                    ((SXSSFSheet) sheet).flushRows();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span> (Exception e)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">        &#125;</div><div class="line">        ByteArrayOutputStream ot = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">        workbook.write(ot);</div><div class="line">        <span class="comment">//不调用此方法会在tomcat/temp/poifiles下生成  **.xml文件，并且不会清理，调用清理临时文件</span></div><div class="line">        workbook.dispose();</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo Tips]]></title>
      <url>/2016/04/09/tips/</url>
      <content type="html"><![CDATA[<p><img src="data:image/png;base64,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" alt=""></p>
<a id="more"></a>
<p>通过<a href="http://haymai.cc/2016/04/06/hexo/" target="_blank" rel="external">Hexo 安装教程</a>,我们已经能基本使用Hexo了。但是笔者在使用过程中还是遇到了一些问题，在这一篇中希望能总结一些经验，不能说是很有用的东西，也只是希望做一个记录。遇到了能在这里找到解决方法。</p>
<h3 id="代码提交到了Github上"><a href="#代码提交到了Github上" class="headerlink" title="代码提交到了Github上"></a>代码提交到了Github上</h3><p>我把hexo的源码和主题的修改都用<a href="https://github.com/haymaicc/xiamu/tree/master" target="_blank" rel="external">Git提交到了Github上</a>,如果想看本站源码可以down下来，Git具体操作<a href="http://1ke.co/course/194" target="_blank" rel="external">这篇文章</a>介绍的很详细，我也是通过这篇文章Get到套路的。</p>
<h3 id="Node-forever"><a href="#Node-forever" class="headerlink" title="Node forever"></a>Node forever</h3><p>在搭好环境后，我发现有时候莫名其妙的Hexo就挂了，然后整个网站就无法浏览，实际上通过Node forever 就可以解决这个问题，原理就是在后台用定时任务去跑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure></p>
<p>如果挂了就重启。具体怎么做呢？</p>
<blockquote>
<ul>
<li>通过<strong>npm</strong>安装forever</li>
<li>在hexo目录下写好一个javascript脚本</li>
<li>通过forever定时执行该脚本</li>
</ul>
</blockquote>
<p>1、通过<strong>npm</strong>安装forever，执行如下命令安装forever<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo npm install forever -g   #安装</div></pre></td></tr></table></figure></p>
<p>2、在hexo的根目录下新建一个haymai.js文件，内容如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn;</div><div class="line">free = spawn(<span class="string">'hexo'</span>, [<span class="string">'server'</span>, <span class="string">'-p 80'</span>]);</div><div class="line"></div><div class="line">free.stdout.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'standard output:\n'</span> + data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">free.stderr.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123; </div><div class="line"><span class="built_in">console</span>.log(<span class="string">'standard error output:\n'</span> + data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">free.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code, signal</span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'child process eixt ,exit:'</span> + code);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>3、执行如下命令跑定时任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ forever --minUptime 10000 --spinSleepTime 26000 start haymai.js</div></pre></td></tr></table></figure></p>
<h3 id="加入RSS和Sitemap"><a href="#加入RSS和Sitemap" class="headerlink" title="加入RSS和Sitemap"></a>加入RSS和Sitemap</h3><p>1、在Hexo根目录执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-generator-feed</div><div class="line">$ npm install hexo-generator-sitemap</div></pre></td></tr></table></figure></p>
<p>2、在Hexo根目录下加入<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Extensions</span></div><div class="line"><span class="attr">Plugins:</span></div><div class="line"><span class="bullet">-</span> hexo-generator-feed</div><div class="line"><span class="bullet">-</span> hexo-generator-sitemap</div><div class="line"></div><div class="line"><span class="comment">#Feed Atom</span></div><div class="line"><span class="attr">feed:</span></div><div class="line"><span class="attr">  type:</span> atom</div><div class="line"><span class="attr">  path:</span> atom.xml</div><div class="line"><span class="attr">  limit:</span> <span class="number">20</span></div><div class="line"></div><div class="line"><span class="comment">#sitemap</span></div><div class="line"><span class="attr">sitemap:</span></div><div class="line"><span class="attr">  path:</span> sitemap.xml</div></pre></td></tr></table></figure></p>
<p>3、执行hexo clean和hexo deploy 后，打开haymai.cc/atom.xml，haymai.cc/sitemap.xml即可看到已生效</p>
<h3 id="公益404页面"><a href="#公益404页面" class="headerlink" title="公益404页面"></a>公益404页面</h3><p><a href="haymai.cc/aaa">haymai.cc/aaa -&gt; 腾讯公益</a><br>这个真心蛋疼死了，网上大多数人说只要把一个404.html放进source文件夹就行了，但是我放了死活不行，结果找了半天，原来是用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure></p>
<p>启动的不会去跳转到404.html，这不就是说hexo 没有这功能？！ 最终我只好祭出杀手锏，抛弃 hexo启动，转而将public文件夹路径指向了tomcat ROOT应用，然后配置ROOT下的web.xml如下内容：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>当然source下的404.html 也要加上，这里用了腾旭公益404页面，内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">layout: false</div><div class="line">title: &quot;404&quot;</div><div class="line">---</div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt;</div><div class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;</div><div class="line">  &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt;</div><div class="line">  &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;http://www.haymai.cc&quot; homePageName=&quot;回到唐伯虎点蜡烛&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>不知道各位看官是怎么解决的，有没有更好的方法？</p>
<h3 id="网易云音乐引入"><a href="#网易云音乐引入" class="headerlink" title="网易云音乐引入"></a>网易云音乐引入</h3><p>哈哈，网站第一次发声，链的网易云，在页面上加入如下代码，你也能听我的红心啦~23333</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div style=&quot;max-width: 350px;max-height: 150px&quot;&gt;</div><div class="line">&lt;embed style=&quot;margin-top: -35px;&quot; frameborder=&quot;no&quot; border=&quot;0&quot;marginwidth=&quot;0&quot; marginheight=&quot;0&quot; src=&quot;https://music.163.com/outchain/player?type=0&amp;id=28560713&amp;auto=0&amp;height=90&quot;&gt;&lt;/embed&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<div style="max-width: 350px;max-height: 150px"><br><embed style="margin-top: -35px;" frameborder="no" border="0" marginwidth="0" marginheight="0" src="https://music.163.com/outchain/player?type=0&id=28560713&auto=1&height=90"><br></div>

<p>作者 <a href="http://weibo.com/u/2413072655?s_all=1&amp;is_all=1" target="_blank" rel="external">夏目</a><br>2016 年 04月 09日</p>
]]></content>
      
        <categories>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 安装教程]]></title>
      <url>/2016/04/06/hexo/</url>
      <content type="html"><![CDATA[<p>近来觉得需要一隅来发发牢骚，于是用Hexo搭建了这个博客。</p>
<p><img src="http://i.v2ex.co/5bb7J7NT.png" alt=""></p>
<a id="more"></a>
<p><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo官网</a>介绍的很酷炫，实际上用起来也让我觉得很强大，但是开发文档编写的相当羞涩，所以在这总结一下Hexo的安装教程，希望对大家有所帮助。</p>
<p>首先要想使用Hexo,有两个先决条件：</p>
<blockquote>
<p>安装Git(可以通过GitHub down 一些主题，还有一些源码)<br>安装node.js</p>
</blockquote>
<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>这个相当简单，通过 <a href="https://git-scm.com/download/linux/" target="_blank" rel="external">Git linux命令即可安装</a> ，但是笔者的用的阿里云suse版本的linux，使用Git官网的zypper软件源</p>
<pre><code>$ zypper install git</code></pre>

<p>安装不成功，遂在网上下载了源码，解压安装。</p>
<h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>安装 <a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a> </p>
<pre><code>$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh | bash</code></pre>
CURL安装node
<pre><code>$ curl https://raw.github.com/creationix/nvm/master/install.sh| sh</code></pre>
重启终端并执行下列命令即可安装 Node.js。
<pre><code>$ nvm install 4</code></pre>

<h3 id="所有必备的应用程序安装完成后，即可使用npm安装Hexo。"><a href="#所有必备的应用程序安装完成后，即可使用npm安装Hexo。" class="headerlink" title="所有必备的应用程序安装完成后，即可使用npm安装Hexo。"></a>所有必备的应用程序安装完成后，即可使用npm安装Hexo。</h3><p>如果第一条命令失败，可以试试 –unsafe那条命令安装。</p>
<pre><code>$ npm install -g hexo-cli
$ npm install --unsafe-perm -g hexo-cli</code></pre>

<h3 id="Hexo-基本操作"><a href="#Hexo-基本操作" class="headerlink" title="Hexo 基本操作"></a>Hexo 基本操作</h3><p>到这里Hexo的运行环境基本搭建完成，若是在安装过程中遇到一些依赖包找不到的情况，再用npm安装一些依赖包。<br>Hexo的简单操作，可以看官网的命令介绍 <a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="external">Hexo指令</a><br>通过</p>
<pre><code>$ hexo init [folder]</code></pre>
建立网站，folder就是hexo 要安装的文件夹，若不指定则在当前目录建立。值得一提的是在Hexo安装目录下有个_config.yml文件，可以配置Hexo的一些基本参数，如网站的标题什么的。
然后通过 
<pre><code>$ hexo new [layout]</code></pre>

<p>新建文章，layout默认有三种：post、page 和 draft，存在source/_posts 文件夹。<br>执行完new 命令会生成一个 xxx.md 文件，通过markdown来编写文章，附上 <a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">markdown在线编辑器</a></p>
<p>还有几个常用的 <strong>命令</strong></p>
<pre><code>$ hexo clean
$ hexo generate
$ hexo server -p 80</code></pre>

<p>用来清理和生成静态文件，以固定端口启动hexo</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>[1]:<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">Hexo Themes 主题下载</a>,通过如下命令下载到主题文件夹</p>
<pre><code>git clone git://github.com/SuperKieran/TKL [folder]</code></pre>
[2]:查看Hexo 进程
<pre><code>ps -aux | grep hexo</code></pre>


<hr>
<p>再一次感谢您花费时间阅读，祝您在这里记录、阅读、分享愉快！</p>
<p>作者 <a href="http://weibo.com/u/2413072655?s_all=1&amp;is_all=1" target="_blank" rel="external">夏目</a><br>2016 年 04月 06日</p>
]]></content>
      
        <categories>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
